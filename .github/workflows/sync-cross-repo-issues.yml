name: Sync Cross-Repo Issues

on:
  schedule:
    # Run every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      full_sync:
        description: 'Perform full sync (check all issues)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  sync-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Sync Cross-Repo Child Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const helper = require('./.github/scripts/cross-repo-helper.js');

            // Configuration
            const PROJECT_NAME = 'EngageMe';  // Change this to your project name
            const DELAY_MS = 500;  // Delay between operations to avoid rate limiting
            const FULL_SYNC = context.eventName === 'workflow_dispatch'
              ? context.payload.inputs.full_sync === 'true'
              : false;

            console.log(`Starting sync (full_sync: ${FULL_SYNC})...`);

            // Get all issues in the repository
            const allIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: FULL_SYNC ? 'all' : 'open',  // Only open issues unless full sync
              per_page: 100
            });

            console.log(`Found ${allIssues.length} issue(s) to check`);

            // Filter for issues that might have children (Epics and Features)
            const parentIssues = allIssues.filter(issue =>
              !issue.pull_request &&
              (issue.title.startsWith('[EPIC]') || issue.title.startsWith('[FEATURE]'))
            );

            console.log(`Found ${parentIssues.length} parent issue(s) (Epics/Features)`);

            if (parentIssues.length === 0) {
              console.log('No parent issues to sync');
              return;
            }

            // Find the project
            const project = await helper.findProject(github, context.repo.owner, PROJECT_NAME);
            if (!project) {
              console.error(`Project "${PROJECT_NAME}" not found`);
              return;
            }
            console.log(`Found project: ${project.title}`);

            // Get project fields
            const projectFields = await helper.getProjectFields(github, project.id);
            const typeField = helper.findField(projectFields, 'Type');
            const iterationField = helper.findField(projectFields, 'Iteration') ||
                                  helper.findField(projectFields, 'Sprint');

            // Track results
            const results = {
              issuesChecked: 0,
              childrenProcessed: 0,
              childrenSkipped: 0,
              errors: []
            };

            // Process each parent issue
            for (const parentIssue of parentIssues) {
              await helper.delay(DELAY_MS);

              // Check if this issue has child issues
              if (!parentIssue.sub_issues_summary || !parentIssue.sub_issues_summary.sub_issues) {
                continue;
              }

              const childIssues = parentIssue.sub_issues_summary.sub_issues;
              if (childIssues.length === 0) continue;

              results.issuesChecked++;
              console.log(`\nChecking #${parentIssue.number}: ${parentIssue.title} (${childIssues.length} children)`);

              // Get parent issue's iteration
              let parentIterationId = null;
              try {
                const parentProjectItem = await helper.findProjectItem(github, project.id, parentIssue.node_id);
                if (parentProjectItem && iterationField) {
                  const parentFields = await helper.getProjectItemFields(github, project.id, parentProjectItem.id);
                  const iterationValue = parentFields.find(f =>
                    f.field && f.field.name === iterationField.name
                  );
                  if (iterationValue && iterationValue.iterationId) {
                    parentIterationId = iterationValue.iterationId;
                  }
                }
              } catch (error) {
                console.log('Could not get parent iteration:', error.message);
              }

              // Process each child
              for (const child of childIssues) {
                await helper.delay(DELAY_MS);

                const childRef = helper.parseIssueUrl(child.url);
                if (!childRef) {
                  console.log(`Could not parse URL: ${child.url}`);
                  continue;
                }

                // Skip same-repo issues
                if (helper.isSameRepo(childRef, context.repo.owner, context.repo.repo)) {
                  results.childrenSkipped++;
                  continue;
                }

                console.log(`  Checking ${childRef.owner}/${childRef.repo}#${childRef.number}...`);

                try {
                  // Get child issue details
                  const childIssue = await helper.getIssue(
                    github,
                    childRef.owner,
                    childRef.repo,
                    childRef.number
                  );

                  let updated = false;

                  // 1. Ensure child is in project
                  let childProjectItem = await helper.findProjectItem(github, project.id, childIssue.node_id);

                  if (!childProjectItem) {
                    console.log(`    Adding to project...`);
                    const itemId = await helper.addIssueToProject(github, project.id, childIssue.node_id);
                    childProjectItem = { id: itemId };
                    updated = true;
                    await helper.delay(DELAY_MS);
                  }

                  // 2. Check/update Type field
                  if (typeField && childProjectItem) {
                    const issueType = helper.getIssueTypeFromTitle(childIssue.title);
                    if (issueType) {
                      const typeOption = typeField.options.find(o => o.name === issueType);
                      if (typeOption) {
                        // Get current type value
                        const currentFields = await helper.getProjectItemFields(github, project.id, childProjectItem.id);
                        const currentType = currentFields.find(f =>
                          f.field && f.field.name === 'Type'
                        );

                        if (!currentType || currentType.name !== issueType) {
                          console.log(`    Setting Type to "${issueType}"...`);
                          await helper.updateSingleSelectField(
                            github,
                            project.id,
                            childProjectItem.id,
                            typeField.id,
                            typeOption.id
                          );
                          updated = true;
                          await helper.delay(DELAY_MS);
                        }
                      }
                    }
                  }

                  // 3. Check/update iteration
                  if (iterationField && parentIterationId && childProjectItem) {
                    const currentFields = await helper.getProjectItemFields(github, project.id, childProjectItem.id);
                    const currentIteration = currentFields.find(f =>
                      f.field && f.field.name === iterationField.name
                    );

                    if (!currentIteration || currentIteration.iterationId !== parentIterationId) {
                      console.log(`    Syncing iteration from parent...`);
                      await helper.updateIterationField(
                        github,
                        project.id,
                        childProjectItem.id,
                        iterationField.id,
                        parentIterationId
                      );
                      updated = true;
                      await helper.delay(DELAY_MS);
                    }
                  }

                  // 4. Check/update milestone
                  if (parentIssue.milestone && !childIssue.milestone) {
                    console.log(`    Setting milestone to "${parentIssue.milestone.title}"...`);
                    await helper.copyMilestone(
                      github,
                      childRef.owner,
                      childRef.repo,
                      childRef.number,
                      parentIssue.milestone
                    );
                    updated = true;
                    await helper.delay(DELAY_MS);
                  }

                  if (updated) {
                    console.log(`    âœ… Updated ${childRef.owner}/${childRef.repo}#${childRef.number}`);
                    results.childrenProcessed++;
                  } else {
                    console.log(`    âœ“ Already synced`);
                    results.childrenSkipped++;
                  }

                } catch (error) {
                  console.error(`    âŒ Error: ${error.message}`);
                  results.errors.push({
                    parent: `#${parentIssue.number}`,
                    child: `${childRef.owner}/${childRef.repo}#${childRef.number}`,
                    error: error.message
                  });
                }
              }
            }

            // Create summary issue if there were updates or errors
            if (results.childrenProcessed > 0 || results.errors.length > 0) {
              let summary = `# ðŸ”„ Cross-Repo Sync Summary\n\n`;
              summary += `**Sync Type:** ${FULL_SYNC ? 'Full' : 'Incremental'}\n`;
              summary += `**Date:** ${new Date().toUTCString()}\n\n`;
              summary += `## Statistics\n\n`;
              summary += `- **Parent Issues Checked:** ${results.issuesChecked}\n`;
              summary += `- **Children Updated:** ${results.childrenProcessed}\n`;
              summary += `- **Children Skipped:** ${results.childrenSkipped}\n`;
              summary += `- **Errors:** ${results.errors.length}\n\n`;

              if (results.errors.length > 0) {
                summary += `## Errors\n\n`;
                for (const error of results.errors) {
                  summary += `- Parent ${error.parent} â†’ Child ${error.child}: ${error.error}\n`;
                }
                summary += '\n';
              }

              summary += `---\n*Generated by [Sync Cross-Repo Issues](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/master/.github/workflows/sync-cross-repo-issues.yml)*`;

              // Find or create sync log issue
              const syncLogIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'automation-log',
                state: 'open',
                per_page: 1
              });

              if (syncLogIssues.data.length > 0) {
                // Add comment to existing log
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: syncLogIssues.data[0].number,
                  body: summary
                });
                console.log(`Added sync log to issue #${syncLogIssues.data[0].number}`);
              } else {
                // Create new log issue
                const logIssue = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: 'ðŸ”„ Cross-Repo Automation Log',
                  body: `This issue tracks cross-repository automation sync operations.\n\n${summary}`,
                  labels: ['automation-log', 'documentation']
                });
                console.log(`Created sync log issue #${logIssue.data.number}`);
              }
            }

            console.log('\n=== Final Summary ===');
            console.log(`Parent Issues Checked: ${results.issuesChecked}`);
            console.log(`Children Updated: ${results.childrenProcessed}`);
            console.log(`Children Skipped: ${results.childrenSkipped}`);
            console.log(`Errors: ${results.errors.length}`);
