name: Cascade Iteration to Children

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to cascade iteration from'
        required: true
        type: number
  issues:
    types: [edited, labeled]

jobs:
  cascade-iteration:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      repository-projects: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cascade Iteration to Descendants
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_WITH_PROJECT_ACCESS || secrets.GITHUB_TOKEN }}
          script: |
            console.log('üîÑ Iteration cascade workflow triggered');

            // Determine issue number based on trigger type
            let issueNumber;
            if (context.eventName === 'workflow_dispatch') {
              // Manual trigger
              issueNumber = parseInt(context.payload.inputs.issue_number);
              console.log(`Manual trigger for issue #${issueNumber}`);
            } else if (context.eventName === 'issues') {
              // Issue event trigger - only proceed if it's an edit and has iteration label
              issueNumber = context.issue.number;
              console.log(`Issue event trigger for issue #${issueNumber}`);

              // For now, we'll cascade whenever an issue is edited
              // In a real implementation, you'd check if iteration changed via project API
            } else {
              console.log('Unknown trigger type');
              return;
            }

            console.log(`Processing issue #${issueNumber}`);

            // Function to find all child issues (supports cross-repository)
            async function findChildIssues(parentNumber) {
              console.log(`üîç Looking for children of issue #${parentNumber}...`);

              // Use GraphQL to get sub-issues (supports cross-repository relationships)
              try {
                const graphqlQuery = `
                  query {
                    repository(owner: "${context.repo.owner}", name: "${context.repo.repo}") {
                      issue(number: ${parentNumber}) {
                        trackedIssues(first: 100) {
                          nodes {
                            number
                            repository {
                              name
                              owner {
                                login
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const result = await github.graphql(graphqlQuery);
                const children = result.repository.issue.trackedIssues.nodes;

                if (children && children.length > 0) {
                  // Log with repo info for cross-repo children
                  const childLabels = children.map(c => {
                    if (c.repository.name !== context.repo.repo) {
                      return `${c.repository.name}#${c.number}`;
                    }
                    return `#${c.number}`;
                  }).join(', ');

                  console.log(`Found ${children.length} child issue(s): ${childLabels}`);
                  return children; // Return full objects with repository info
                }
              } catch (error) {
                console.log(`Could not get sub-issues from GraphQL: ${error.message}`);
              }

              console.log('No children found');
              return [];
            }

            // Function to get project item and iteration for an issue (supports cross-repo)
            async function getProjectIteration(issueNumber, owner = context.repo.owner, repo = context.repo.repo) {
              const issue = await github.rest.issues.get({
                owner: owner,
                repo: repo,
                issue_number: issueNumber
              });

              const issueNodeId = issue.data.node_id;

              // Get all projects and their items (organization-level)
              const projectQuery = `
                query($owner: String!) {
                  organization(login: $owner) {
                    projectsV2(first: 10) {
                      nodes {
                        id
                        title
                        items(first: 100) {
                          nodes {
                            id
                            content {
                              ... on Issue {
                                id
                                number
                              }
                            }
                            fieldValues(first: 20) {
                              nodes {
                                ... on ProjectV2ItemFieldIterationValue {
                                  title
                                  duration
                                  startDate
                                  id
                                  iterationId
                                  field {
                                    ... on ProjectV2IterationField {
                                      id
                                      name
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        fields(first: 20) {
                          nodes {
                            ... on ProjectV2IterationField {
                              id
                              name
                              configuration {
                                iterations {
                                  id
                                  title
                                  startDate
                                  duration
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `;

              const projectResult = await github.graphql(projectQuery, {
                owner: context.repo.owner
              });

              const projects = projectResult.organization.projectsV2.nodes;

              // Find the specific project "[TEMPLATE] EngageMe"
              const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

              if (!project) {
                console.log(`‚ö†Ô∏è  Issue #${issueNumber} - [TEMPLATE] EngageMe project not found`);
                return null;
              }

              // Find the item for this issue
              const item = project.items.nodes.find(i =>
                i.content && i.content.number === issueNumber
              );

              if (item) {
                // Find iteration value
                const iterationValue = item.fieldValues.nodes.find(fv =>
                  fv.field && fv.field.name === 'Iteration'
                );

                // Find iteration field
                const iterationField = project.fields.nodes.find(f =>
                  f.name === 'Iteration'
                );

                return {
                  projectId: project.id,
                  itemId: item.id,
                  iteration: iterationValue ? {
                    id: iterationValue.iterationId,
                    title: iterationValue.title
                  } : null,
                  iterationField: iterationField
                };
              }

              return null;
            }

            // Function to update iteration field
            async function updateIterationField(projectId, itemId, fieldId, iterationId) {
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $iterationId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: {
                      iterationId: $iterationId
                    }
                  }) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;

              await github.graphql(mutation, {
                projectId: projectId,
                itemId: itemId,
                fieldId: fieldId,
                iterationId: iterationId
              });
            }

            // Function to recursively update all descendants with iteration
            async function updateDescendantsIteration(parentNumber, iteration, depth = 0, updatedIssues = new Set()) {
              const indent = '  '.repeat(depth);
              console.log(`${indent}Cascading iteration to descendants of #${parentNumber}...`);

              const children = await findChildIssues(parentNumber);

              for (const child of children) {
                // Extract repository info for cross-repo support
                const childOwner = child.repository?.owner?.login || context.repo.owner;
                const childRepo = child.repository?.name || context.repo.repo;
                const childNumber = child.number;
                const repoLabel = childRepo !== context.repo.repo ? `${childRepo}#${childNumber}` : `#${childNumber}`;

                // Avoid infinite loops
                if (updatedIssues.has(childNumber)) {
                  console.log(`${indent}‚è≠Ô∏è  Skipping ${repoLabel} (already processed)`);
                  continue;
                }

                updatedIssues.add(childNumber);

                // Get child's project info
                const childProjectInfo = await getProjectIteration(childNumber, childOwner, childRepo);

                if (!childProjectInfo) {
                  console.log(`${indent}‚ö†Ô∏è  ${repoLabel} not found in any project`);
                  continue;
                }

                const currentIteration = childProjectInfo.iteration?.title || 'none';
                const targetIteration = iteration?.title || 'none';

                if (currentIteration !== targetIteration) {
                  console.log(`${indent}üìù Updating ${repoLabel} iteration from "${currentIteration}" to "${targetIteration}"`);

                  try {
                    if (iteration && iteration.id) {
                      await updateIterationField(
                        childProjectInfo.projectId,
                        childProjectInfo.itemId,
                        childProjectInfo.iterationField.id,
                        iteration.id
                      );
                      console.log(`${indent}‚úÖ Updated ${repoLabel}`);
                    } else {
                      console.log(`${indent}‚ÑπÔ∏è  No iteration to set on ${repoLabel}`);
                    }
                  } catch (error) {
                    console.error(`${indent}Error updating ${repoLabel}:`, error.message);
                  }
                } else {
                  console.log(`${indent}‚è≠Ô∏è  ${repoLabel} already has correct iteration`);
                }

                // Recursively update grandchildren
                await updateDescendantsIteration(childNumber, iteration, depth + 1, updatedIssues);
              }

              return updatedIssues;
            }

            // Get the current issue's iteration
            const parentProjectInfo = await getProjectIteration(issueNumber);

            if (!parentProjectInfo) {
              console.log('Parent issue not found in any project');
              return;
            }

            const iteration = parentProjectInfo.iteration;
            console.log(`Parent iteration: ${iteration?.title || 'none'}`);

            // Start cascading
            const updatedDescendants = await updateDescendantsIteration(issueNumber, iteration);

            if (updatedDescendants.size > 0) {
              console.log(`‚úÖ Updated ${updatedDescendants.size} descendant issue(s) with iteration "${iteration?.title || 'none'}"`);
            } else {
              console.log('‚ÑπÔ∏è  No descendants found or all already up-to-date');
            }

            console.log('‚úÖ Iteration cascade complete!');
