name: Issue Automation

on:
  issues:
    types: [opened, edited, reopened, closed, milestoned, demilestoned, assigned, unassigned, labeled, unlabeled]

jobs:
  automate-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      repository-projects: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @octokit/graphql

      - name: Auto-set Type and Inherit Milestone
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_WITH_PROJECT_ACCESS || secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = context.issue.number;
            const issueBody = context.payload.issue.body || '';
            const issueTitle = context.payload.issue.title || '';

            // Function to find all child issues (issues that reference this issue as parent)
            async function findChildIssues(parentNumber) {
              const allIssues = [];
              let page = 1;
              let hasMore = true;

              while (hasMore) {
                const issues = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  per_page: 100,
                  page: page
                });

                if (issues.data.length === 0) {
                  hasMore = false;
                } else {
                  allIssues.push(...issues.data);
                  page++;
                }
              }

              // Filter issues that reference this issue as parent
              const children = allIssues.filter(issue => {
                const body = issue.body || '';
                // Remove HTML comments to avoid matching examples
                const bodyWithoutComments = body.replace(/<!--[\s\S]*?-->/g, '');
                const parentPattern = new RegExp(`(?:Epic|Feature|Parent Feature|Parent Epic):\\s*#${parentNumber}(?:\\s|$)`, 'i');
                return parentPattern.test(bodyWithoutComments);
              });

              console.log(`Found ${children.length} child issue(s) of #${parentNumber}`);
              return children;
            }

            // Function to recursively update all descendants with milestone
            async function updateDescendantsMilestone(parentNumber, milestone, depth = 0, updatedIssues = new Set()) {
              const indent = '  '.repeat(depth);
              console.log(`${indent}Checking descendants of #${parentNumber}...`);

              const children = await findChildIssues(parentNumber);

              for (const child of children) {
                // Avoid infinite loops
                if (updatedIssues.has(child.number)) {
                  console.log(`${indent}‚è≠Ô∏è  Skipping #${child.number} (already processed)`);
                  continue;
                }

                updatedIssues.add(child.number);

                const currentMilestone = child.milestone ? child.milestone.number : null;
                const targetMilestone = milestone ? milestone.number : null;

                if (currentMilestone !== targetMilestone) {
                  console.log(`${indent}üìù Updating #${child.number} milestone from "${child.milestone?.title || 'none'}" to "${milestone?.title || 'none'}"`);

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: child.number,
                    milestone: targetMilestone
                  });

                  console.log(`${indent}‚úÖ Updated #${child.number}`);
                } else {
                  console.log(`${indent}‚è≠Ô∏è  #${child.number} already has correct milestone`);
                }

                // Recursively update grandchildren
                await updateDescendantsMilestone(child.number, milestone, depth + 1, updatedIssues);
              }

              return updatedIssues;
            }

            // Determine issue type from title prefix
            let issueType = null;
            if (issueTitle.startsWith('[EPIC]')) {
              issueType = 'Epic';
            } else if (issueTitle.startsWith('[FEATURE]')) {
              issueType = 'Feature';
            } else if (issueTitle.startsWith('[STORY]')) {
              issueType = 'User Story';
            } else if (issueTitle.startsWith('[Task]')) {
              issueType = 'Task';
            }

            console.log(`Issue #${issueNumber}: Type detected as "${issueType}"`);

            // Remove HTML comments from body to avoid matching examples
            const bodyWithoutComments = issueBody.replace(/<!--[\s\S]*?-->/g, '');

            // Extract parent issue reference
            const parentMatch = bodyWithoutComments.match(/(?:Epic|Feature|Parent Feature|Parent Epic):\s*#(\d+)/i);
            let parentIssueNumber = null;
            let parentMilestone = null;

            if (parentMatch) {
              parentIssueNumber = parseInt(parentMatch[1]);
              console.log(`Parent issue reference found: #${parentIssueNumber}`);

              // Get parent issue details to inherit milestone
              try {
                const parentIssue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parentIssueNumber
                });

                if (parentIssue.data.milestone) {
                  parentMilestone = parentIssue.data.milestone;
                  console.log(`Parent milestone found: ${parentMilestone.title}`);

                  // Set milestone on current issue
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    milestone: parentMilestone.number
                  });

                  console.log(`‚úÖ Milestone "${parentMilestone.title}" inherited from parent issue #${parentIssueNumber}`);
                } else {
                  console.log('Parent issue has no milestone set');
                }

                // Inherit iteration from parent
                console.log(`\nüìÖ Checking for parent iteration...`);

                // Function to get iteration for an issue
                async function getIssueIteration(issueNum) {
                  const projectQuery = `
                    query($owner: String!) {
                      organization(login: $owner) {
                        projectsV2(first: 10) {
                          nodes {
                            id
                            title
                            items(first: 100) {
                              nodes {
                                id
                                content {
                                  ... on Issue {
                                    number
                                  }
                                }
                                fieldValues(first: 20) {
                                  nodes {
                                    ... on ProjectV2ItemFieldIterationValue {
                                      title
                                      iterationId
                                      field {
                                        ... on ProjectV2IterationField {
                                          id
                                          name
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            fields(first: 20) {
                              nodes {
                                ... on ProjectV2IterationField {
                                  id
                                  name
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  `;

                  const result = await github.graphql(projectQuery, {
                    owner: context.repo.owner
                  });

                  const projects = result.organization.projectsV2.nodes;
                  const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

                  if (!project) return null;

                  const item = project.items.nodes.find(i => i.content && i.content.number === issueNum);
                  if (!item) return null;

                  const iterationValue = item.fieldValues.nodes.find(fv =>
                    fv.field && fv.field.name === 'Iteration' && fv.iterationId
                  );

                  if (!iterationValue) return null;

                  const iterationField = project.fields.nodes.find(f => f.name === 'Iteration');

                  return {
                    projectId: project.id,
                    itemId: item.id,
                    iteration: {
                      id: iterationValue.iterationId,
                      title: iterationValue.title
                    },
                    iterationFieldId: iterationField ? iterationField.id : null
                  };
                }

                // Get parent's iteration
                const parentIterationInfo = await getIssueIteration(parentIssueNumber);

                if (parentIterationInfo && parentIterationInfo.iteration) {
                  console.log(`Parent iteration found: ${parentIterationInfo.iteration.title}`);

                  // Get current issue's project info
                  const childIterationInfo = await getIssueIteration(issueNumber);

                  if (childIterationInfo && childIterationInfo.iterationFieldId) {
                    // Set iteration on child issue
                    const updateIterationMutation = `
                      mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $iterationId: String!) {
                        updateProjectV2ItemFieldValue(input: {
                          projectId: $projectId
                          itemId: $itemId
                          fieldId: $fieldId
                          value: {
                            iterationId: $iterationId
                          }
                        }) {
                          projectV2Item {
                            id
                          }
                        }
                      }
                    `;

                    await github.graphql(updateIterationMutation, {
                      projectId: childIterationInfo.projectId,
                      itemId: childIterationInfo.itemId,
                      fieldId: childIterationInfo.iterationFieldId,
                      iterationId: parentIterationInfo.iteration.id
                    });

                    console.log(`‚úÖ Iteration "${parentIterationInfo.iteration.title}" inherited from parent issue #${parentIssueNumber}`);
                  } else {
                    console.log('‚ö†Ô∏è  Child issue not found in project or iteration field missing');
                  }
                } else {
                  console.log('Parent issue has no iteration set');
                }
              } catch (error) {
                console.error(`Error fetching parent issue #${parentIssueNumber}:`, error.message);
              }
            } else {
              console.log('No parent issue reference found in issue body');
            }

            // Set GitHub Issue Type field (organizational issue type)
            if (issueType) {
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  type: issueType
                });
                console.log(`‚úÖ Issue Type set to "${issueType}"`);
              } catch (error) {
                console.error('Error setting issue type:', error.message);
                console.log('‚ö†Ô∏è  Note: Issue types require push access and must be configured in your organization');
                console.log('‚ö†Ô∏è  Available types can be checked with: gh api orgs/:org/issue-types');
              }
            }

            // Set project field (Type) using GraphQL
            if (issueType) {
              try {
                // Get the issue node ID
                const issueData = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                const issueNodeId = issueData.data.node_id;

                // Find projects associated with this repository (organization-level)
                const projectsQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          fields(first: 20) {
                            nodes {
                              ... on ProjectV2SingleSelectField {
                                id
                                name
                                options {
                                  id
                                  name
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const projectsResult = await github.graphql(projectsQuery, {
                  owner: context.repo.owner
                });

                const projects = projectsResult.organization.projectsV2.nodes;
                console.log(`Found ${projects.length} project(s)`);

                // Find the specific project "[TEMPLATE] EngageMe"
                const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

                if (!project) {
                  console.log('‚ö†Ô∏è  [TEMPLATE] EngageMe project not found');
                } else {
                  console.log(`Processing project: ${project.title}`);

                  // Add issue to project first
                  const addToProjectMutation = `
                    mutation($projectId: ID!, $contentId: ID!) {
                      addProjectV2ItemById(input: {
                        projectId: $projectId
                        contentId: $contentId
                      }) {
                        item {
                          id
                        }
                      }
                    }
                  `;

                  let itemId;
                  try {
                    const addResult = await github.graphql(addToProjectMutation, {
                      projectId: project.id,
                      contentId: issueNodeId
                    });
                    itemId = addResult.addProjectV2ItemById.item.id;
                    console.log(`‚úÖ Issue added to project with item ID: ${itemId}`);
                  } catch (error) {
                    console.log(`Issue might already be in project: ${error.message}`);
                    // If already in project, we need to find the item ID
                    // Try to find it in the project items
                    const projectQuery = `
                      query($owner: String!) {
                        organization(login: $owner) {
                          projectsV2(first: 10) {
                            nodes {
                              id
                              title
                              items(first: 100) {
                                nodes {
                                  id
                                  content {
                                    ... on Issue {
                                      number
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const projectResult = await github.graphql(projectQuery, {
                      owner: context.repo.owner
                    });

                    const targetProject = projectResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                    if (targetProject) {
                      const item = targetProject.items.nodes.find(i => i.content && i.content.number === issueNumber);
                      if (item) {
                        itemId = item.id;
                        console.log(`‚úÖ Found existing item ID: ${itemId}`);
                      }
                    }
                  }

                  if (!itemId) {
                    console.log('‚ö†Ô∏è  Could not get item ID, skipping project field update');
                  } else {
                    // Find the Type field
                    const typeField = project.fields.nodes.find(field =>
                      field.name === 'Type' && field.options
                    );

                    if (typeField) {
                      console.log(`Found Type field with ID: ${typeField.id}`);

                      // Find the matching option
                      const typeOption = typeField.options.find(opt =>
                        opt.name === issueType
                      );

                      if (typeOption) {
                        console.log(`Found matching type option: ${typeOption.name} (${typeOption.id})`);

                        // Update the field value
                        const updateFieldMutation = `
                          mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                            updateProjectV2ItemFieldValue(input: {
                              projectId: $projectId
                              itemId: $itemId
                              fieldId: $fieldId
                              value: {
                                singleSelectOptionId: $optionId
                              }
                            }) {
                              projectV2Item {
                                id
                              }
                            }
                          }
                        `;

                        await github.graphql(updateFieldMutation, {
                          projectId: project.id,
                          itemId: itemId,
                          fieldId: typeField.id,
                          optionId: typeOption.id
                        });

                        console.log(`‚úÖ Type field set to "${issueType}" in project "${project.title}"`);
                      } else {
                        console.log(`‚ö†Ô∏è Type option "${issueType}" not found in project field. Available options: ${typeField.options.map(o => o.name).join(', ')}`);
                      }
                    } else {
                      console.log('‚ö†Ô∏è Type field not found in project. Please create a single-select field named "Type" with options: Epic, Feature, User Story, Task');
                    }
                  }
                }
              } catch (error) {
                console.error('Error setting project field:', error.message);
                if (error.errors) {
                  console.error('GraphQL errors:', JSON.stringify(error.errors, null, 2));
                }
              }
            }

            // ========================================
            // Validation: Estimate Required for In Progress
            // ========================================

            if (issueType === 'Task' || issueType === 'User Story') {
              console.log(`\nüîç Validating estimate for ${issueType}...`);

              try {
                // Get project fields including Status and Estimate
                const issueData = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                const issueNodeId = issueData.data.node_id;

                // Query project for Status and Estimate fields
                const projectQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          items(first: 100) {
                            nodes {
                              id
                              content {
                                ... on Issue {
                                  id
                                  number
                                }
                              }
                              fieldValues(first: 20) {
                                nodes {
                                  ... on ProjectV2ItemFieldNumberValue {
                                    number
                                    field {
                                      ... on ProjectV2Field {
                                        id
                                        name
                                      }
                                    }
                                  }
                                  ... on ProjectV2ItemFieldSingleSelectValue {
                                    name
                                    field {
                                      ... on ProjectV2SingleSelectField {
                                        id
                                        name
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const projectResult = await github.graphql(projectQuery, {
                  owner: context.repo.owner
                });

                const projects = projectResult.organization.projectsV2.nodes;
                const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

                if (project) {
                  const item = project.items.nodes.find(i => i.content && i.content.number === issueNumber);

                  if (item) {
                    // Extract Status and Estimate values
                    let statusValue = null;
                    let estimateValue = 0;

                    item.fieldValues.nodes.forEach(fv => {
                      if (fv.field) {
                        if (fv.field.name === 'Status' && fv.name) {
                          statusValue = fv.name;
                        }
                        if (fv.field.name === 'Estimate' && fv.number !== undefined) {
                          estimateValue = fv.number;
                        }
                      }
                    });

                    console.log(`üìä Status: "${statusValue}", Estimate: ${estimateValue}`);

                    // Validation: If Status is "In Progress" and Estimate is 0, add warning
                    if (statusValue === 'In Progress' && estimateValue === 0) {
                      console.log('‚ö†Ô∏è  Validation failed: In Progress without estimate');

                      // Add label
                      await github.rest.issues.addLabels({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        labels: ['needs-estimate']
                      });

                      // Post warning comment
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        body: `### ‚ö†Ô∏è Validation Warning\n\nThis issue is marked as **In Progress** but has **no Estimate** set.\n\n**Action required:** Please add an estimate (in hours or story points) to the project board before continuing work.\n\n*Label \`needs-estimate\` has been added. Remove it after setting the estimate.*`
                      });

                      console.log('‚úÖ Added needs-estimate label and warning comment');
                    } else if (statusValue === 'In Progress' && estimateValue > 0) {
                      // Remove label if estimate is now set
                      try {
                        await github.rest.issues.removeLabel({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber,
                          name: 'needs-estimate'
                        });
                        console.log('‚úÖ Removed needs-estimate label (estimate now set)');
                      } catch (error) {
                        // Label might not exist, ignore error
                      }
                    } else {
                      console.log('‚úÖ Validation passed');
                    }
                  } else {
                    console.log('‚ÑπÔ∏è  Issue not found in project, skipping validation');
                  }
                } else {
                  console.log('‚ÑπÔ∏è  [TEMPLATE] EngageMe project not found, skipping validation');
                }
              } catch (error) {
                console.error('Error during validation:', error.message);
              }
            }

            // Cascade milestone updates to all descendants
            const currentMilestone = context.payload.issue.milestone;
            const actionType = context.payload.action;

            let updatedDescendants = new Set();
            if (['milestoned', 'demilestoned', 'edited'].includes(actionType)) {
              console.log(`\nüîÑ Cascading milestone changes to all descendants of #${issueNumber}...`);
              updatedDescendants = await updateDescendantsMilestone(issueNumber, currentMilestone);

              if (updatedDescendants.size > 0) {
                console.log(`‚úÖ Updated ${updatedDescendants.size} descendant issue(s) with milestone "${currentMilestone?.title || 'none'}"`);
              } else {
                console.log('‚ÑπÔ∏è  No descendants found or all already up-to-date');
              }
            }

            // Create comment summarizing automation actions
            let commentBody = '### ü§ñ Automation Summary\n\n';
            if (issueType) {
              commentBody += `‚úÖ **Type**: Set to \`${issueType}\`\n`;
            }
            if (parentMilestone) {
              commentBody += `‚úÖ **Milestone**: Inherited \`${parentMilestone.title}\` from parent issue #${parentIssueNumber}\n`;
            }
            if (parentIssueNumber && !parentMilestone) {
              commentBody += `‚ÑπÔ∏è **Note**: Parent issue #${parentIssueNumber} has no milestone to inherit\n`;
            }
            // Note: Iteration inheritance is handled above but not included in comment as it runs separately
            if (updatedDescendants.size > 0) {
              const descendantList = Array.from(updatedDescendants).map(n => `#${n}`).join(', ');
              commentBody += `\nüîÑ **Cascaded Updates**: Milestone propagated to ${updatedDescendants.size} descendant(s): ${descendantList}\n`;
            }

            if (issueType || parentMilestone || updatedDescendants.size > 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: commentBody
              });
            }

            // ========================================
            // Auto-Close/Reopen Parent Issues
            // ========================================

            if (actionType === 'closed' || actionType === 'reopened') {
              console.log(`\nüîÑ Issue #${issueNumber} was ${actionType}, syncing parent state...`);

              // Function to sync parent state based on all children
              async function syncParentState(childIssueNumber, depth = 0) {
                const indent = '  '.repeat(depth);

                // Get the child issue to find its parent
                const childIssue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: childIssueNumber
                });

                const childBody = childIssue.data.body || '';
                const bodyWithoutComments = childBody.replace(/<!--[\s\S]*?-->/g, '');
                const parentMatch = bodyWithoutComments.match(/(?:Epic|Feature|Parent Feature|Parent Epic):\s*#(\d+)/i);

                if (!parentMatch) {
                  console.log(`${indent}‚ÑπÔ∏è  Issue #${childIssueNumber} has no parent reference`);
                  return;
                }

                const parentNumber = parseInt(parentMatch[1]);
                console.log(`${indent}üìã Found parent: #${parentNumber}`);

                // Get parent issue
                let parentIssue;
                try {
                  parentIssue = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber
                  });
                } catch (error) {
                  console.log(`${indent}‚ö†Ô∏è  Parent issue #${parentNumber} not found: ${error.message}`);
                  return;
                }

                // Find all children of this parent
                const allChildren = await findChildIssues(parentNumber);

                if (allChildren.length === 0) {
                  console.log(`${indent}‚ÑπÔ∏è  Parent #${parentNumber} has no children (relationship may be inconsistent)`);
                  return;
                }

                // Check if all children are closed
                const allClosed = allChildren.every(child => child.state === 'closed');
                const anyClosed = allChildren.some(child => child.state === 'closed');
                const anyOpen = allChildren.some(child => child.state === 'open');

                console.log(`${indent}üìä Parent #${parentNumber} status: ${allChildren.length} children, ${allChildren.filter(c => c.state === 'closed').length} closed, ${allChildren.filter(c => c.state === 'open').length} open`);

                const parentState = parentIssue.data.state;
                let actionTaken = false;

                // If all children closed and parent is open ‚Üí close parent
                if (allClosed && parentState === 'open') {
                  console.log(`${indent}‚úÖ All children closed, closing parent #${parentNumber}`);

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber,
                    state: 'closed',
                    state_reason: 'completed'
                  });

                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber,
                    body: `### üîí Auto-Closed\n\nAll ${allChildren.length} child issue(s) have been completed:\n${allChildren.map(c => `- #${c.number} (${c.title})`).join('\n')}\n\n*Automatically closed by workflow*`
                  });

                  actionTaken = true;
                }

                // If any child open and parent is closed ‚Üí reopen parent
                if (anyOpen && parentState === 'closed') {
                  console.log(`${indent}üîì Child reopened, reopening parent #${parentNumber}`);

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber,
                    state: 'open'
                  });

                  const openChildren = allChildren.filter(c => c.state === 'open');
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber,
                    body: `### üîì Auto-Reopened\n\n${openChildren.length} child issue(s) are still open:\n${openChildren.map(c => `- #${c.number} (${c.title})`).join('\n')}\n\n*Automatically reopened by workflow*`
                  });

                  actionTaken = true;
                }

                if (!actionTaken) {
                  console.log(`${indent}‚è≠Ô∏è  Parent #${parentNumber} already in correct state (${parentState})`);
                }

                // Recursively sync grandparent
                await syncParentState(parentNumber, depth + 1);
              }

              // Start the sync chain from this issue
              await syncParentState(issueNumber);
              console.log('‚úÖ Parent state sync complete!');
            }
