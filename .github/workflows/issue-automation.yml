name: Issue Automation

on:
  issues:
    types: [opened, edited, reopened, closed, milestoned, demilestoned, assigned, unassigned, labeled, unlabeled]

env:
  # Configuration - Update these for your environment
  PROJECT_NAME: '[TEMPLATE] EngageMe'
  FIELD_TYPE: 'Type'
  FIELD_ESTIMATE: 'Estimate'
  FIELD_REMAINING: 'Remaining'
  FIELD_ITERATION: 'Iteration'
  FIELD_STATUS: 'Status'

jobs:
  automate-issue:
    runs-on: ubuntu-latest
    timeout-minutes: 10  # Prevent workflows from hanging indefinitely
    permissions:
      issues: write
      contents: read
      repository-projects: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @octokit/graphql

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}

      - name: Auto-set Type and Inherit Milestone
        uses: actions/github-script@v7
        env:
          PROJECT_NAME: ${{ env.PROJECT_NAME }}
          FIELD_TYPE: ${{ env.FIELD_TYPE }}
          FIELD_ESTIMATE: ${{ env.FIELD_ESTIMATE }}
          FIELD_REMAINING: ${{ env.FIELD_REMAINING }}
          FIELD_ITERATION: ${{ env.FIELD_ITERATION }}
          FIELD_STATUS: ${{ env.FIELD_STATUS }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // ============================================
            // Configuration
            // ============================================
            const CONFIG = {
              projectName: process.env.PROJECT_NAME,
              fields: {
                type: process.env.FIELD_TYPE,
                estimate: process.env.FIELD_ESTIMATE,
                remaining: process.env.FIELD_REMAINING,
                iteration: process.env.FIELD_ITERATION,
                status: process.env.FIELD_STATUS
              }
            };

            const issueNumber = context.issue.number;
            const issueBody = context.payload.issue.body || '';
            const issueTitle = context.payload.issue.title || '';

            // Function to find all child issues (supports cross-repository)
            async function findChildIssues(parentNumber, owner = context.repo.owner, repo = context.repo.repo) {
              const repoLabel = (owner !== context.repo.owner || repo !== context.repo.repo) ? `${owner}/${repo}#${parentNumber}` : `#${parentNumber}`;
              console.log(`üîç Looking for children of issue ${repoLabel}...`);

              // Use REST API sub_issues endpoint (properly supports cross-repository relationships)
              try {
                const response = await github.request('GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues', {
                  owner: owner,
                  repo: repo,
                  issue_number: parentNumber
                });

                const children = response.data;

                if (children && children.length > 0) {
                  // Log with repo info for cross-repo children
                  const childLabels = children.map(c => {
                    const repo = c.repository?.name || context.repo.repo;
                    const owner = c.repository?.owner?.login || context.repo.owner;
                    if (repo !== context.repo.repo || owner !== context.repo.owner) {
                      return owner + '/' + repo + '#' + c.number;
                    }
                    return '#' + c.number;
                  }).join(', ');

                  console.log('‚úÖ Found ' + children.length + ' child issue(s): ' + childLabels);

                  // Transform REST API response to match expected structure
                  return children.map(child => ({
                    id: child.node_id,
                    number: child.number,
                    state: child.state,
                    title: child.title,
                    milestone: child.milestone ? {
                      number: child.milestone.number,
                      title: child.milestone.title
                    } : null,
                    labels: { nodes: child.labels || [] },
                    repository: child.repository ? {
                      name: child.repository.name,
                      owner: { login: child.repository.owner.login }
                    } : {
                      name: context.repo.repo,
                      owner: { login: context.repo.owner }
                    }
                  }));
                }
              } catch (error) {
                console.log('‚ö†Ô∏è  Could not get sub-issues: ' + error.message);
                console.log('This may happen if the issue has no children or API access is limited');
              }

              console.log('No children found');
              return [];
            }

            async function closeAllDescendants(parentNumber, depth = 0, closedIssues = new Set(), owner = context.repo.owner, repo = context.repo.repo) {
              const indent = '  '.repeat(depth);
              const repoLabel = (owner !== context.repo.owner || repo !== context.repo.repo) ? `${owner}/${repo}#${parentNumber}` : `#${parentNumber}`;
              console.log(`${indent}üîí Closing all descendants of ${repoLabel}...`);

              const children = await findChildIssues(parentNumber, owner, repo);

              for (const child of children) {
                const childOwner = child.repository?.owner?.login || context.repo.owner;
                const childRepo = child.repository?.name || context.repo.repo;
                const childNumber = child.number;
                const isCrossRepo = childRepo !== context.repo.repo || childOwner !== context.repo.owner;
                const repoLabel = isCrossRepo ? `${childOwner}/${childRepo}#${childNumber}` : `#${childNumber}`;
                const issueKey = `${childOwner}/${childRepo}#${childNumber}`;

                if (closedIssues.has(issueKey)) {
                  console.log(`${indent}‚è≠Ô∏è  Skipping ${repoLabel} (already processed)`);
                  continue;
                }

                closedIssues.add(issueKey);

                try {
                  if (child.state === 'open') {
                    console.log(`${indent}üîí Closing ${repoLabel}: ${child.title}`);

                    await github.rest.issues.update({
                      owner: childOwner,
                      repo: childRepo,
                      issue_number: childNumber,
                      state: 'closed',
                      state_reason: 'completed'
                    });

                    console.log(`${indent}‚úÖ Closed ${repoLabel}`);

                    // Recursively close grandchildren (including cross-repo)
                    await closeAllDescendants(childNumber, depth + 1, closedIssues, childOwner, childRepo);
                  } else {
                    console.log(`${indent}‚è≠Ô∏è  ${repoLabel} already closed`);
                  }
                } catch (error) {
                  if (error.status === 410) {
                    console.log(`${indent}‚ö†Ô∏è  ${repoLabel} was deleted, skipping`);
                  } else if (error.status === 404) {
                    console.log(`${indent}‚ö†Ô∏è  ${repoLabel} not found or not accessible, skipping`);
                  } else if (error.status === 403) {
                    console.log(`${indent}‚ö†Ô∏è  No permission to close ${repoLabel}, skipping`);
                  } else {
                    console.log(`${indent}‚ùå Error closing ${repoLabel}: ${error.message}`);
                  }
                }
              }

              return closedIssues;
            }

            async function updateDescendantsMilestone(parentNumber, milestone, depth = 0, updatedIssues = new Set(), owner = context.repo.owner, repo = context.repo.repo) {
              const indent = '  '.repeat(depth);
              const repoLabel = (owner !== context.repo.owner || repo !== context.repo.repo) ? `${owner}/${repo}#${parentNumber}` : `#${parentNumber}`;
              console.log(`${indent}Checking descendants of ${repoLabel}...`);

              const children = await findChildIssues(parentNumber, owner, repo);

              for (const child of children) {
                // Extract repository info for cross-repo support
                const childOwner = child.repository?.owner?.login || context.repo.owner;
                const childRepo = child.repository?.name || context.repo.repo;
                const childNumber = child.number;
                const isCrossRepo = childRepo !== context.repo.repo || childOwner !== context.repo.owner;
                const repoLabel = isCrossRepo ? `${childOwner}/${childRepo}#${childNumber}` : `#${childNumber}`;

                // Create unique key for cross-repo tracking
                const issueKey = `${childOwner}/${childRepo}#${childNumber}`;

                // Avoid infinite loops
                if (updatedIssues.has(issueKey)) {
                  console.log(`${indent}‚è≠Ô∏è  Skipping ${repoLabel} (already processed)`);
                  continue;
                }

                updatedIssues.add(issueKey);

                try {
                  const currentMilestone = child.milestone ? child.milestone.number : null;
                  const targetMilestone = milestone ? milestone.number : null;

                  if (currentMilestone !== targetMilestone) {
                    console.log(`${indent}üìù Updating ${repoLabel} milestone from "${child.milestone?.title || 'none'}" to "${milestone?.title || 'none'}"`);

                    await github.rest.issues.update({
                      owner: childOwner,
                      repo: childRepo,
                      issue_number: childNumber,
                      milestone: targetMilestone
                    });

                    console.log(`${indent}‚úÖ Updated ${repoLabel}`);
                  } else {
                    console.log(`${indent}‚è≠Ô∏è  ${repoLabel} already has correct milestone`);
                  }

                  // Recursively update grandchildren (including cross-repo)
                  await updateDescendantsMilestone(childNumber, milestone, depth + 1, updatedIssues, childOwner, childRepo);
                } catch (error) {
                  if (error.status === 410) {
                    console.log(`${indent}‚ö†Ô∏è  ${repoLabel} was deleted, skipping`);
                  } else if (error.status === 404) {
                    console.log(`${indent}‚ö†Ô∏è  ${repoLabel} not found or not accessible, skipping`);
                  } else if (error.status === 403) {
                    console.log(`${indent}‚ö†Ô∏è  No permission to update ${repoLabel}, skipping`);
                  } else {
                    console.log(`${indent}‚ùå Error updating ${repoLabel}: ${error.message}`);
                  }
                }
              }

              return updatedIssues;
            }

            // Function to recursively update all descendants with label changes
            async function updateDescendantsLabels(parentNumber, labelName, operation, depth = 0, updatedIssues = new Set(), owner = context.repo.owner, repo = context.repo.repo) {
              const indent = '  '.repeat(depth);
              const repoLabel = (owner !== context.repo.owner || repo !== context.repo.repo) ? `${owner}/${repo}#${parentNumber}` : `#${parentNumber}`;
              console.log(`${indent}Checking descendants of ${repoLabel} for label ${operation}...`);

              const children = await findChildIssues(parentNumber, owner, repo);

              for (const child of children) {
                // Extract repository info for cross-repo support
                const childOwner = child.repository?.owner?.login || context.repo.owner;
                const childRepo = child.repository?.name || context.repo.repo;
                const childNumber = child.number;
                const isCrossRepo = childRepo !== context.repo.repo || childOwner !== context.repo.owner;
                const repoLabel = isCrossRepo ? `${childOwner}/${childRepo}#${childNumber}` : `#${childNumber}`;

                // Create unique key for cross-repo tracking
                const issueKey = `${childOwner}/${childRepo}#${childNumber}`;

                // Avoid infinite loops
                if (updatedIssues.has(issueKey)) {
                  console.log(`${indent}‚è≠Ô∏è  Skipping ${repoLabel} (already processed)`);
                  continue;
                }

                updatedIssues.add(issueKey);

                try {
                  if (operation === 'add') {
                    // Check if child already has the label (from GraphQL response)
                    const hasLabel = child.labels && child.labels.nodes && child.labels.nodes.some(l => l.name === labelName);

                    if (!hasLabel) {
                      console.log(`${indent}üè∑Ô∏è  Adding label "${labelName}" to ${repoLabel}`);
                      await github.rest.issues.addLabels({
                        owner: childOwner,
                        repo: childRepo,
                        issue_number: childNumber,
                        labels: [labelName]
                      });
                      console.log(`${indent}‚úÖ Added label to ${repoLabel}`);
                    } else {
                      console.log(`${indent}‚è≠Ô∏è  ${repoLabel} already has label "${labelName}"`);
                    }
                  } else if (operation === 'remove') {
                    console.log(`${indent}üóëÔ∏è  Removing label "${labelName}" from ${repoLabel}`);
                    await github.rest.issues.removeLabel({
                      owner: childOwner,
                      repo: childRepo,
                      issue_number: childNumber,
                      name: labelName
                    });
                    console.log(`${indent}‚úÖ Removed label from ${repoLabel}`);
                  }
                } catch (error) {
                  if (error.status === 410) {
                    console.log(`${indent}‚ö†Ô∏è  ${repoLabel} was deleted, skipping`);
                  } else if (error.status === 404) {
                    console.log(`${indent}‚ö†Ô∏è  ${repoLabel} or label not found, skipping`);
                  } else if (error.status === 403) {
                    console.log(`${indent}‚ö†Ô∏è  No permission to update ${repoLabel}, skipping`);
                  } else {
                    console.log(`${indent}‚ö†Ô∏è  Could not ${operation} label on ${repoLabel}: ${error.message}`);
                  }
                }

                // Recursively update grandchildren (including cross-repo)
                await updateDescendantsLabels(childNumber, labelName, operation, depth + 1, updatedIssues, childOwner, childRepo);
              }

              return updatedIssues;
            }

            async function updateDescendantsTypes(parentNumber, depth = 0, updatedIssues = new Set(), owner = context.repo.owner, repo = context.repo.repo) {
              const indent = '  '.repeat(depth);
              const repoLabel = (owner !== context.repo.owner || repo !== context.repo.repo) ? `${owner}/${repo}#${parentNumber}` : `#${parentNumber}`;
              console.log(`${indent}üè∑Ô∏è  Setting types for descendants of ${repoLabel}...`);

              const children = await findChildIssues(parentNumber, owner, repo);

              for (const child of children) {
                const childOwner = child.repository?.owner?.login || context.repo.owner;
                const childRepo = child.repository?.name || context.repo.repo;
                const childNumber = child.number;
                const childRepoLabel = (childRepo !== context.repo.repo || childOwner !== context.repo.owner) ? `${childOwner}/${childRepo}#${childNumber}` : `#${childNumber}`;
                const issueKey = `${childOwner}/${childRepo}#${childNumber}`;

                if (updatedIssues.has(issueKey)) {
                  console.log(`${indent}‚è≠Ô∏è  Skipping ${childRepoLabel} (already processed)`);
                  continue;
                }

                updatedIssues.add(issueKey);

                try {
                  // Get child issue details
                  const childIssue = await github.rest.issues.get({
                    owner: childOwner,
                    repo: childRepo,
                    issue_number: childNumber
                  });

                  // Determine type from title
                  const childTitle = childIssue.data.title;
                  let childType = null;
                  if (childTitle.startsWith('[EPIC]')) childType = 'Epic';
                  else if (childTitle.startsWith('[FEATURE]')) childType = 'Feature';
                  else if (childTitle.startsWith('[STORY]')) childType = 'User Story';
                  else if (childTitle.startsWith('[TASK]') || childTitle.startsWith('[Task]')) childType = 'Task';

                  if (childType) {
                    // Set organization-level issue type
                    try {
                      await github.rest.issues.update({
                        owner: childOwner,
                        repo: childRepo,
                        issue_number: childNumber,
                        type: childType
                      });
                      console.log(`${indent}  ‚úÖ Set organization type to "${childType}" for ${childRepoLabel}`);
                    } catch (typeError) {
                      console.log(`${indent}  ‚ö†Ô∏è  Could not set organization type: ${typeError.message}`);
                    }

                    // Set project Type field
                    try {
                      const projectQuery = `
                        query($owner: String!) {
                          organization(login: $owner) {
                            projectsV2(first: 10) {
                              nodes {
                                id
                                title
                                items(first: 100) {
                                  nodes {
                                    id
                                    content {
                                      ... on Issue {
                                        id
                                      }
                                    }
                                  }
                                }
                                fields(first: 20) {
                                  nodes {
                                    ... on ProjectV2SingleSelectField {
                                      id
                                      name
                                      options {
                                        id
                                        name
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      `;

                      const projectResult = await github.graphql(projectQuery, {
                        owner: context.repo.owner
                      });

                      const project = projectResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                      if (project) {
                        const projectItem = project.items.nodes.find(i =>
                          i.content && i.content.id === childIssue.data.node_id
                        );

                        if (projectItem) {
                          const typeField = project.fields.nodes.find(f => f.name === 'Type');
                          if (typeField) {
                            const typeOption = typeField.options.find(o => o.name === childType);
                            if (typeOption) {
                              const updateMutation = `
                                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: ProjectV2FieldValue!) {
                                  updateProjectV2ItemFieldValue(input: {
                                    projectId: $projectId
                                    itemId: $itemId
                                    fieldId: $fieldId
                                    value: $value
                                  }) {
                                    projectV2Item { id }
                                  }
                                }
                              `;

                              await github.graphql(updateMutation, {
                                projectId: project.id,
                                itemId: projectItem.id,
                                fieldId: typeField.id,
                                value: { singleSelectOptionId: typeOption.id }
                              });

                              console.log(`${indent}  ‚úÖ Set project Type to "${childType}" for ${childRepoLabel}`);
                            }
                          }
                        }
                      }
                    } catch (projectError) {
                      console.log(`${indent}  ‚ö†Ô∏è  Could not set project type: ${projectError.message}`);
                    }
                  }

                  // Recursively update grandchildren (including cross-repo)
                  await updateDescendantsTypes(childNumber, depth + 1, updatedIssues, childOwner, childRepo);

                } catch (error) {
                  if (error.status === 410) {
                    console.log(`${indent}‚ö†Ô∏è  ${childRepoLabel} was deleted, skipping`);
                  } else if (error.status === 404) {
                    console.log(`${indent}‚ö†Ô∏è  ${childRepoLabel} not found or not accessible, skipping`);
                  } else {
                    console.log(`${indent}‚ùå Error processing ${childRepoLabel}: ${error.message}`);
                  }
                }
              }

              return updatedIssues;
            }

            async function updateDescendantsIterations(parentNumber, depth = 0, updatedIssues = new Set(), owner = context.repo.owner, repo = context.repo.repo) {
              const indent = '  '.repeat(depth);
              const repoLabel = (owner !== context.repo.owner || repo !== context.repo.repo) ? `${owner}/${repo}#${parentNumber}` : `#${parentNumber}`;
              console.log(`${indent}üìÖ Setting iterations for descendants of ${repoLabel}...`);

              // Get parent's iteration first
              let parentIteration = null;
              try {
                const parentIterationQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          items(first: 100) {
                            nodes {
                              content {
                                ... on Issue {
                                  id
                                  number
                                  repository {
                                    name
                                    owner {
                                      login
                                    }
                                  }
                                }
                              }
                              fieldValues(first: 20) {
                                nodes {
                                  ... on ProjectV2ItemFieldIterationValue {
                                    title
                                    iterationId
                                    field {
                                      ... on ProjectV2IterationField {
                                        id
                                        name
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          fields(first: 20) {
                            nodes {
                              ... on ProjectV2IterationField {
                                id
                                name
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const parentIterResult = await github.graphql(parentIterationQuery, {
                  owner: context.repo.owner
                });

                const parentIterProject = parentIterResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                if (parentIterProject) {
                  // Find the parent issue's item in the project
                  const parentItem = parentIterProject.items.nodes.find(i => {
                    if (!i.content) return false;
                    const itemOwner = i.content.repository?.owner?.login || context.repo.owner;
                    const itemRepo = i.content.repository?.name || context.repo.repo;
                    return i.content.number === parentNumber && itemOwner === owner && itemRepo === repo;
                  });

                  if (parentItem) {
                    const iterationValue = parentItem.fieldValues.nodes.find(fv =>
                      fv.field && fv.field.name === 'Iteration' && fv.iterationId
                    );

                    if (iterationValue) {
                      parentIteration = {
                        title: iterationValue.title,
                        iterationId: iterationValue.iterationId,
                        fieldId: iterationValue.field.id,
                        projectId: parentIterProject.id,
                        project: parentIterProject
                      };
                      console.log(`${indent}  Parent has iteration: ${iterationValue.title}`);
                    }
                  }
                }
              } catch (error) {
                console.log(`${indent}  ‚ö†Ô∏è  Could not get parent iteration: ${error.message}`);
              }

              if (!parentIteration) {
                console.log(`${indent}  ‚ÑπÔ∏è  Parent has no iteration, skipping descendants`);
                return updatedIssues;
              }

              const children = await findChildIssues(parentNumber, owner, repo);

              for (const child of children) {
                const childOwner = child.repository?.owner?.login || context.repo.owner;
                const childRepo = child.repository?.name || context.repo.repo;
                const childNumber = child.number;
                const childRepoLabel = (childRepo !== context.repo.repo || childOwner !== context.repo.owner) ? `${childOwner}/${childRepo}#${childNumber}` : `#${childNumber}`;
                const issueKey = `${childOwner}/${childRepo}#${childNumber}`;

                if (updatedIssues.has(issueKey)) {
                  console.log(`${indent}‚è≠Ô∏è  Skipping ${childRepoLabel} (already processed)`);
                  continue;
                }

                updatedIssues.add(issueKey);

                try {
                  // Get child issue details
                  const childIssue = await github.rest.issues.get({
                    owner: childOwner,
                    repo: childRepo,
                    issue_number: childNumber
                  });

                  // Check if child is in project
                  const childItemQuery = `
                    query($owner: String!) {
                      organization(login: $owner) {
                        projectsV2(first: 10) {
                          nodes {
                            id
                            title
                            items(first: 100) {
                              nodes {
                                id
                                content {
                                  ... on Issue {
                                    id
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  `;

                  const childItemResult = await github.graphql(childItemQuery, {
                    owner: context.repo.owner
                  });

                  const childProject = childItemResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                  if (childProject) {
                    const childProjectItem = childProject.items.nodes.find(i =>
                      i.content && i.content.id === childIssue.data.node_id
                    );

                    if (childProjectItem) {
                      // Set iteration on child
                      const setIterationMutation = `
                        mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $iterationId: String!) {
                          updateProjectV2ItemFieldValue(input: {
                            projectId: $projectId
                            itemId: $itemId
                            fieldId: $fieldId
                            value: { iterationId: $iterationId }
                          }) {
                            projectV2Item { id }
                          }
                        }
                      `;

                      await github.graphql(setIterationMutation, {
                        projectId: childProject.id,
                        itemId: childProjectItem.id,
                        fieldId: parentIteration.fieldId,
                        iterationId: parentIteration.iterationId
                      });

                      console.log(`${indent}  ‚úÖ Set iteration "${parentIteration.title}" for ${childRepoLabel}`);
                    } else {
                      console.log(`${indent}  ‚ÑπÔ∏è  ${childRepoLabel} not in project, skipping iteration`);
                    }
                  }

                  // Recursively update grandchildren (including cross-repo)
                  await updateDescendantsIterations(childNumber, depth + 1, updatedIssues, childOwner, childRepo);

                } catch (error) {
                  if (error.status === 410) {
                    console.log(`${indent}‚ö†Ô∏è  ${childRepoLabel} was deleted, skipping`);
                  } else if (error.status === 404) {
                    console.log(`${indent}‚ö†Ô∏è  ${childRepoLabel} not found or not accessible, skipping`);
                  } else {
                    console.log(`${indent}‚ùå Error processing ${childRepoLabel}: ${error.message}`);
                  }
                }
              }

              return updatedIssues;
            }

            // Determine issue type from title prefix
            let issueType = null;
            if (issueTitle.startsWith('[EPIC]')) {
              issueType = 'Epic';
            } else if (issueTitle.startsWith('[FEATURE]')) {
              issueType = 'Feature';
            } else if (issueTitle.startsWith('[STORY]')) {
              issueType = 'User Story';
            } else if (issueTitle.startsWith('[Task]')) {
              issueType = 'Task';
            }

            if (issueType) {
              console.log(`Issue #${issueNumber}: Type detected as "${issueType}"`);
            }

            // Function to find parent issue using GitHub's native relationships
            async function findParentIssue(issueNum) {
              console.log(`üîç Looking for parent of issue #${issueNum}...`);

              // Method 1: Check for parent using REST API
              // GitHub's REST API has parent_issue_url field that actually works!
              try {
                const childIssue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum
                });

                if (childIssue.data.parent_issue_url) {
                  // Extract parent number from URL: .../issues/42
                  const parentNum = parseInt(childIssue.data.parent_issue_url.split('/').pop());
                  console.log(`‚úÖ Parent found via REST API: #${parentNum}`);

                  // Get parent details
                  const parentIssue = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNum
                  });

                  return {
                    number: parentNum,
                    milestone: parentIssue.data.milestone,
                    labels: parentIssue.data.labels || []
                  };
                }
              } catch (error) {
                console.log(`‚ö†Ô∏è  Could not get parent from REST API: ${error.message}`);
              }

              // Method 2: Fall back to description parsing
              console.log('Checking issue description for parent reference...');
              const issue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNum
              });

              const bodyWithoutComments = (issue.data.body || '').replace(/<!--[\s\S]*?-->/g, '');
              const parentMatch = bodyWithoutComments.match(/(?:Epic|Feature|Parent Feature|Parent Epic):\s*#(\d+)/i);

              if (parentMatch) {
                const parentNum = parseInt(parentMatch[1]);
                console.log(`‚úÖ Parent found via description: #${parentNum}`);

                const parentIssue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parentNum
                });

                return {
                  number: parentNum,
                  milestone: parentIssue.data.milestone,
                  labels: parentIssue.data.labels || []
                };
              }

              console.log('‚ÑπÔ∏è  No parent issue found');
              return null;
            }

            // Find parent issue
            let parentIssueNumber = null;
            let parentMilestone = null;

            try {
              const parent = await findParentIssue(issueNumber);
              if (parent) {
                parentIssueNumber = parent.number;
                parentMilestone = parent.milestone;

                if (parentMilestone) {
                  console.log(`Parent milestone found: ${parentMilestone.title}`);

                  // Set milestone on current issue
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    milestone: parentMilestone.number
                  });

                  console.log(`‚úÖ Milestone "${parentMilestone.title}" inherited from parent issue #${parentIssueNumber}`);
                } else {
                  console.log('Parent issue has no milestone set');
                }

                // Inherit labels from parent
                if (parent.labels && parent.labels.length > 0) {
                  const labelNames = parent.labels.map(l => l.name);
                  console.log(`Inheriting ${labelNames.length} labels from parent: ${labelNames.join(', ')}`);

                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      labels: labelNames
                    });
                    console.log(`‚úÖ Inherited ${labelNames.length} labels from parent`);
                  } catch (error) {
                    console.error(`Error inheriting labels:`, error.message);
                  }
                } else {
                  console.log('Parent issue has no labels to inherit');
                }
              }
            } catch (error) {
              console.error(`Error finding parent issue:`, error.message);
            }

            // Set GitHub Issue Type field (organizational issue type)
            if (issueType) {
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  type: issueType
                });
                console.log(`‚úÖ Issue Type set to "${issueType}"`);
              } catch (error) {
                console.error('Error setting issue type:', error.message);
                console.log('‚ö†Ô∏è  Note: Issue types require push access and must be configured in your organization');
                console.log('‚ö†Ô∏è  Available types can be checked with: gh api orgs/:org/issue-types');
              }
            }

            // Set project field (Type) using GraphQL
            let childProjectId = null;
            let childItemId = null;
            let childProjectFields = null;

            if (issueType) {
              try {
                // Get the issue node ID
                const issueData = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                const issueNodeId = issueData.data.node_id;

                // Find projects associated with this repository (organization-level)
                const projectsQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          fields(first: 20) {
                            nodes {
                              ... on ProjectV2SingleSelectField {
                                id
                                name
                                options {
                                  id
                                  name
                                }
                              }
                              ... on ProjectV2IterationField {
                                id
                                name
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const projectsResult = await github.graphql(projectsQuery, {
                  owner: context.repo.owner
                });

                const projects = projectsResult.organization.projectsV2.nodes;
                console.log(`Found ${projects.length} project(s)`);

                // Find the specific project "[TEMPLATE] EngageMe"
                const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

                if (!project) {
                  console.log('‚ö†Ô∏è  [TEMPLATE] EngageMe project not found');
                } else {
                  console.log(`Processing project: ${project.title}`);

                  // Store project info for later use (iteration inheritance)
                  childProjectId = project.id;
                  childProjectFields = project.fields.nodes;

                  // Add issue to project first
                  const addToProjectMutation = `
                    mutation($projectId: ID!, $contentId: ID!) {
                      addProjectV2ItemById(input: {
                        projectId: $projectId
                        contentId: $contentId
                      }) {
                        item {
                          id
                        }
                      }
                    }
                  `;

                  let itemId;
                  try {
                    const addResult = await github.graphql(addToProjectMutation, {
                      projectId: project.id,
                      contentId: issueNodeId
                    });
                    itemId = addResult.addProjectV2ItemById.item.id;
                    childItemId = itemId;  // Store for iteration inheritance
                    console.log(`‚úÖ Issue added to project with item ID: ${itemId}`);
                  } catch (error) {
                    console.log(`Issue might already be in project: ${error.message}`);
                    // If already in project, we need to find the item ID
                    // Try to find it in the project items
                    const projectQuery = `
                      query($owner: String!) {
                        organization(login: $owner) {
                          projectsV2(first: 10) {
                            nodes {
                              id
                              title
                              items(first: 100) {
                                nodes {
                                  id
                                  content {
                                    ... on Issue {
                                      number
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const projectResult = await github.graphql(projectQuery, {
                      owner: context.repo.owner
                    });

                    const targetProject = projectResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                    if (targetProject) {
                      const item = targetProject.items.nodes.find(i => i.content && i.content.number === issueNumber);
                      if (item) {
                        itemId = item.id;
                        childItemId = itemId;  // Store for iteration inheritance
                        console.log(`‚úÖ Found existing item ID: ${itemId}`);
                      }
                    }
                  }

                  if (!itemId) {
                    console.log('‚ö†Ô∏è  Could not get item ID, skipping project field update');
                  } else {
                    // Find the Type field
                    const typeField = project.fields.nodes.find(field =>
                      field.name === 'Type' && field.options
                    );

                    if (typeField) {
                      console.log(`Found Type field with ID: ${typeField.id}`);

                      // Find the matching option
                      const typeOption = typeField.options.find(opt =>
                        opt.name === issueType
                      );

                      if (typeOption) {
                        console.log(`Found matching type option: ${typeOption.name} (${typeOption.id})`);

                        // Update the field value
                        const updateFieldMutation = `
                          mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                            updateProjectV2ItemFieldValue(input: {
                              projectId: $projectId
                              itemId: $itemId
                              fieldId: $fieldId
                              value: {
                                singleSelectOptionId: $optionId
                              }
                            }) {
                              projectV2Item {
                                id
                              }
                            }
                          }
                        `;

                        await github.graphql(updateFieldMutation, {
                          projectId: project.id,
                          itemId: itemId,
                          fieldId: typeField.id,
                          optionId: typeOption.id
                        });

                        console.log(`‚úÖ Type field set to "${issueType}" in project "${project.title}"`);
                      } else {
                        console.log(`‚ö†Ô∏è Type option "${issueType}" not found in project field. Available options: ${typeField.options.map(o => o.name).join(', ')}`);
                      }
                    } else {
                      console.log('‚ö†Ô∏è Type field not found in project. Please create a single-select field named "Type" with options: Epic, Feature, User Story, Task');
                    }
                  }
                }
              } catch (error) {
                console.error('Error setting project field:', error.message);
                if (error.errors) {
                  console.error('GraphQL errors:', JSON.stringify(error.errors, null, 2));
                }
              }
            }

            // ========================================
            // Inherit iteration from parent (works for ALL issues with a parent)
            // ========================================

            if (parentIssueNumber) {
              console.log(`\nüìÖ Checking for parent iteration...`);

              try {
                // Get child's project info (needed for iteration inheritance)
                const childIssueData = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                const childIssueNodeId = childIssueData.data.node_id;

                // Find child's project item
                const childProjectQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          items(first: 100) {
                            nodes {
                              id
                              content {
                                ... on Issue {
                                  id
                                  number
                                }
                              }
                            }
                          }
                          fields(first: 20) {
                            nodes {
                              ... on ProjectV2IterationField {
                                id
                                name
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const childProjectResult = await github.graphql(childProjectQuery, {
                  owner: context.repo.owner
                });

                const childProjects = childProjectResult.organization.projectsV2.nodes;
                const childProject = childProjects.find(p => p.title === '[TEMPLATE] EngageMe');

                if (!childProject) {
                  console.log('Child issue not in project yet, skipping iteration inheritance');
                } else {
                  const childItem = childProject.items.nodes.find(i =>
                    i.content && i.content.number === issueNumber
                  );

                  if (!childItem) {
                    console.log('Child issue not found in project items, skipping iteration inheritance');
                  } else {
                    const childProjectId = childProject.id;
                    const childItemId = childItem.id;
                    const childProjectFields = childProject.fields.nodes;

                    console.log('Child issue found in project, proceeding with iteration inheritance');

                // Function to get iteration for parent issue
                async function getParentIteration(issueNum) {
                  const projectQuery = `
                    query($owner: String!) {
                      organization(login: $owner) {
                        projectsV2(first: 10) {
                          nodes {
                            id
                            title
                            items(first: 100) {
                              nodes {
                                id
                                content {
                                  ... on Issue {
                                    number
                                  }
                                }
                                fieldValues(first: 20) {
                                  nodes {
                                    ... on ProjectV2ItemFieldIterationValue {
                                      title
                                      iterationId
                                      field {
                                        ... on ProjectV2IterationField {
                                          id
                                          name
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  `;

                  const result = await github.graphql(projectQuery, {
                    owner: context.repo.owner
                  });

                  const projects = result.organization.projectsV2.nodes;
                  const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

                  if (!project) return null;

                  const item = project.items.nodes.find(i => i.content && i.content.number === issueNum);
                  if (!item) return null;

                  const iterationValue = item.fieldValues.nodes.find(fv =>
                    fv.field && fv.field.name === 'Iteration' && fv.iterationId
                  );

                  if (!iterationValue) return null;

                  return {
                    id: iterationValue.iterationId,
                    title: iterationValue.title
                  };
                }

                    // Get parent's iteration
                    const parentIteration = await getParentIteration(parentIssueNumber);

                    if (parentIteration) {
                      console.log(`Parent iteration found: ${parentIteration.title}`);

                      // Find iteration field ID from child project fields
                      const iterationField = childProjectFields.find(f => f.name === 'Iteration');

                      if (iterationField && iterationField.id) {
                        // Set iteration on child issue
                        const updateIterationMutation = `
                          mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $iterationId: String!) {
                            updateProjectV2ItemFieldValue(input: {
                              projectId: $projectId
                              itemId: $itemId
                              fieldId: $fieldId
                              value: {
                                iterationId: $iterationId
                              }
                            }) {
                              projectV2Item {
                                id
                              }
                            }
                          }
                        `;

                        await github.graphql(updateIterationMutation, {
                          projectId: childProjectId,
                          itemId: childItemId,
                          fieldId: iterationField.id,
                          iterationId: parentIteration.id
                        });

                        console.log(`‚úÖ Iteration "${parentIteration.title}" inherited from parent issue #${parentIssueNumber}`);
                      } else {
                        console.log('‚ö†Ô∏è  Iteration field not found in project');
                      }
                    } else {
                      console.log('Parent issue has no iteration set');
                    }
                  }
                }
              } catch (error) {
                console.error(`Error inheriting iteration:`, error.message);
              }
            }

            // ========================================
            // Validation: Estimate Required for In Progress
            // ========================================

            if (issueType === 'Task' || issueType === 'User Story') {
              console.log(`\nüîç Validating estimate for ${issueType}...`);

              try {
                // Get project fields including Status and Estimate
                const issueData = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                const issueNodeId = issueData.data.node_id;

                // Query project for Status and Estimate fields
                const projectQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          items(first: 100) {
                            nodes {
                              id
                              content {
                                ... on Issue {
                                  id
                                  number
                                }
                              }
                              fieldValues(first: 20) {
                                nodes {
                                  ... on ProjectV2ItemFieldNumberValue {
                                    number
                                    field {
                                      ... on ProjectV2Field {
                                        id
                                        name
                                      }
                                    }
                                  }
                                  ... on ProjectV2ItemFieldSingleSelectValue {
                                    name
                                    field {
                                      ... on ProjectV2SingleSelectField {
                                        id
                                        name
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const projectResult = await github.graphql(projectQuery, {
                  owner: context.repo.owner
                });

                const projects = projectResult.organization.projectsV2.nodes;
                const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

                if (project) {
                  const item = project.items.nodes.find(i => i.content && i.content.number === issueNumber);

                  if (item) {
                    // Extract Status and Estimate values
                    let statusValue = null;
                    let estimateValue = 0;

                    item.fieldValues.nodes.forEach(fv => {
                      if (fv.field) {
                        if (fv.field.name === 'Status' && fv.name) {
                          statusValue = fv.name;
                        }
                        if (fv.field.name === 'Estimate' && fv.number !== undefined) {
                          estimateValue = fv.number;
                        }
                      }
                    });

                    console.log(`üìä Status: "${statusValue}", Estimate: ${estimateValue}`);

                    // Validation: If Status is "In Progress" and Estimate is 0, add warning
                    if (statusValue === 'In Progress' && estimateValue === 0) {
                      console.log('‚ö†Ô∏è  Validation failed: In Progress without estimate');

                      // Add label
                      await github.rest.issues.addLabels({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        labels: ['needs-estimate']
                      });


                      console.log('‚úÖ Added needs-estimate label and warning comment');
                    } else if (statusValue === 'In Progress' && estimateValue > 0) {
                      // Remove label if estimate is now set
                      try {
                        await github.rest.issues.removeLabel({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber,
                          name: 'needs-estimate'
                        });
                        console.log('‚úÖ Removed needs-estimate label (estimate now set)');
                      } catch (error) {
                        // Label might not exist, ignore error
                      }
                    } else {
                      console.log('‚úÖ Validation passed');
                    }
                  } else {
                    console.log('‚ÑπÔ∏è  Issue not found in project, skipping validation');
                  }
                } else {
                  console.log('‚ÑπÔ∏è  [TEMPLATE] EngageMe project not found, skipping validation');
                }
              } catch (error) {
                console.error('Error during validation:', error.message);
              }
            }

            // ========================================
            // Process new children when added
            // ========================================
            const actionType = context.payload.action;

            // Check if 'sync' label was added to trigger full sync
            let runFullSync = false;
            if (actionType === 'labeled' && context.payload.label && context.payload.label.name === 'sync') {
              console.log('\nüîÑ "sync" label detected - triggering full synchronization...');
              runFullSync = true;
            }

            if (actionType === 'edited' || runFullSync) {
              console.log(`\nüîç Checking for newly added child issues...`);

              try {
                const children = await findChildIssues(issueNumber);

                if (children && children.length > 0) {
                  console.log(`Found ${children.length} child issue(s), checking which need full setup...`);

                  for (const child of children) {
                    const childOwner = child.repository?.owner?.login || context.repo.owner;
                    const childRepo = child.repository?.name || context.repo.repo;
                    const childNumber = child.number;
                    const isCrossRepo = childRepo !== context.repo.repo || childOwner !== context.repo.owner;
                    const repoLabel = isCrossRepo ? `${childOwner}/${childRepo}#${childNumber}` : `#${childNumber}`;

                    try {
                      // Get child issue details to check if it needs setup
                      const childIssue = await github.rest.issues.get({
                        owner: childOwner,
                        repo: childRepo,
                        issue_number: childNumber
                      });

                      console.log(`\nüìã Processing child ${repoLabel}: ${childIssue.data.title}`);

                      // Check if child is in project
                      let needsProjectSetup = false;
                      const projectQuery = `
                        query($owner: String!) {
                          organization(login: $owner) {
                            projectsV2(first: 10) {
                              nodes {
                                id
                                title
                                items(first: 100) {
                                  nodes {
                                    content {
                                      ... on Issue {
                                        id
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      `;

                      const projectsResult = await github.graphql(projectQuery, {
                        owner: context.repo.owner
                      });

                      const project = projectsResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');

                      if (project) {
                        const isInProject = project.items.nodes.some(item =>
                          item.content && item.content.id === childIssue.data.node_id
                        );

                        if (!isInProject) {
                          needsProjectSetup = true;
                          console.log(`  ‚ûï ${repoLabel} not in project, will add and configure`);
                        } else {
                          console.log(`  ‚úì ${repoLabel} already in project`);
                        }
                      }

                      // Apply full setup if child needs it (especially for cross-repo issues)
                      if (needsProjectSetup || isCrossRepo) {
                        console.log(`  üîß Applying full automation to ${repoLabel}...`);

                        // This child needs full setup - will be handled by cascade operations below
                        // The milestone and label cascade will handle copying those
                        // We just need to ensure it's in the project with correct Type and Iteration

                        // Set organization-level issue type for cross-repo issues
                        if (isCrossRepo) {
                          const childTitle = childIssue.data.title;
                          let childType = null;
                          if (childTitle.startsWith('[EPIC]')) childType = 'Epic';
                          else if (childTitle.startsWith('[FEATURE]')) childType = 'Feature';
                          else if (childTitle.startsWith('[STORY]')) childType = 'User Story';
                          else if (childTitle.startsWith('[TASK]') || childTitle.startsWith('[Task]')) childType = 'Task';

                          if (childType) {
                            try {
                              await github.rest.issues.update({
                                owner: childOwner,
                                repo: childRepo,
                                issue_number: childNumber,
                                type: childType
                              });
                              console.log('  ‚úÖ Set organization Issue Type to "' + childType + '" for ' + repoLabel);
                            } catch (typeError) {
                              console.log('  ‚ö†Ô∏è  Could not set issue type for ' + repoLabel + ': ' + typeError.message);
                            }
                          }
                        }

                        if (needsProjectSetup && project) {
                          // Add to project
                          const addMutation = `
                            mutation($projectId: ID!, $contentId: ID!) {
                              addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                                item {
                                  id
                                }
                              }
                            }
                          `;

                          const addResult = await github.graphql(addMutation, {
                            projectId: project.id,
                            contentId: childIssue.data.node_id
                          });

                          console.log(`  ‚úÖ Added ${repoLabel} to project`);

                          // Set project Type field based on title
                          const childTitle = childIssue.data.title;
                          let childType = null;
                          if (childTitle.startsWith('[EPIC]')) childType = 'Epic';
                          else if (childTitle.startsWith('[FEATURE]')) childType = 'Feature';
                          else if (childTitle.startsWith('[STORY]')) childType = 'User Story';
                          else if (childTitle.startsWith('[TASK]') || childTitle.startsWith('[Task]')) childType = 'Task';

                          if (childType) {
                            const fieldsQuery = `
                              query($projectId: ID!) {
                                node(id: $projectId) {
                                  ... on ProjectV2 {
                                    fields(first: 20) {
                                      nodes {
                                        ... on ProjectV2SingleSelectField {
                                          id
                                          name
                                          options {
                                            id
                                            name
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            `;

                            const fieldsResult = await github.graphql(fieldsQuery, { projectId: project.id });
                            const typeField = fieldsResult.node.fields.nodes.find(f => f.name === 'Type');

                            if (typeField) {
                              const typeOption = typeField.options.find(o => o.name === childType);
                              if (typeOption) {
                                const updateMutation = `
                                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: ProjectV2FieldValue!) {
                                    updateProjectV2ItemFieldValue(input: {
                                      projectId: $projectId
                                      itemId: $itemId
                                      fieldId: $fieldId
                                      value: $value
                                    }) {
                                      projectV2Item { id }
                                    }
                                  }
                                `;

                                await github.graphql(updateMutation, {
                                  projectId: project.id,
                                  itemId: addResult.addProjectV2ItemById.item.id,
                                  fieldId: typeField.id,
                                  value: { singleSelectOptionId: typeOption.id }
                                });

                                console.log(`  ‚úÖ Set Type to "${childType}" for ${repoLabel}`);
                              }
                            }
                          }

                          // Inherit iteration from parent
                          console.log('  üìÖ Checking for parent iteration to inherit...');
                          try {
                            const parentIterationQuery = `
                              query($owner: String!) {
                                organization(login: $owner) {
                                  projectsV2(first: 10) {
                                    nodes {
                                      id
                                      title
                                      items(first: 100) {
                                        nodes {
                                          content {
                                            ... on Issue {
                                              number
                                            }
                                          }
                                          fieldValues(first: 20) {
                                            nodes {
                                              ... on ProjectV2ItemFieldIterationValue {
                                                title
                                                iterationId
                                                field {
                                                  ... on ProjectV2IterationField {
                                                    id
                                                    name
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                      fields(first: 20) {
                                        nodes {
                                          ... on ProjectV2IterationField {
                                            id
                                            name
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            `;

                            const parentIterResult = await github.graphql(parentIterationQuery, {
                              owner: context.repo.owner
                            });

                            const parentIterProject = parentIterResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                            if (parentIterProject) {
                              const parentItem = parentIterProject.items.nodes.find(i =>
                                i.content && i.content.number === issueNumber
                              );

                              if (parentItem) {
                                const iterationValue = parentItem.fieldValues.nodes.find(fv =>
                                  fv.field && fv.field.name === 'Iteration' && fv.iterationId
                                );

                                if (iterationValue) {
                                  console.log('  üìÖ Parent has iteration: ' + iterationValue.title);

                                  const iterationField = parentIterProject.fields.nodes.find(f => f.name === 'Iteration');

                                  if (iterationField) {
                                    const setIterationMutation = `
                                      mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $iterationId: String!) {
                                        updateProjectV2ItemFieldValue(input: {
                                          projectId: $projectId
                                          itemId: $itemId
                                          fieldId: $fieldId
                                          value: { iterationId: $iterationId }
                                        }) {
                                          projectV2Item { id }
                                        }
                                      }
                                    `;

                                    await github.graphql(setIterationMutation, {
                                      projectId: project.id,
                                      itemId: addResult.addProjectV2ItemById.item.id,
                                      fieldId: iterationField.id,
                                      iterationId: iterationValue.iterationId
                                    });

                                    console.log('  ‚úÖ Inherited iteration "' + iterationValue.title + '" from parent');
                                  }
                                } else {
                                  console.log('  ‚ÑπÔ∏è  Parent has no iteration set');
                                }
                              }
                            }
                          } catch (iterError) {
                            console.log('  ‚ö†Ô∏è  Could not inherit iteration: ' + iterError.message);
                          }
                        } else if (isCrossRepo && !needsProjectSetup && project) {
                          // Child is already in project, but it's cross-repo - still need to set type and iteration
                          console.log('  üîç Checking type and iteration for existing cross-repo child...');
                          try {
                            // Find the child's item ID in the project
                            const childItemQuery = `
                              query($owner: String!) {
                                organization(login: $owner) {
                                  projectsV2(first: 10) {
                                    nodes {
                                      id
                                      title
                                      items(first: 100) {
                                        nodes {
                                          id
                                          content {
                                            ... on Issue {
                                              id
                                              number
                                            }
                                          }
                                        }
                                      }
                                      fields(first: 20) {
                                        nodes {
                                          ... on ProjectV2IterationField {
                                            id
                                            name
                                          }
                                          ... on ProjectV2SingleSelectField {
                                            id
                                            name
                                            options {
                                              id
                                              name
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            `;

                            const childItemResult = await github.graphql(childItemQuery, {
                              owner: context.repo.owner
                            });

                            const childItemProject = childItemResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                            if (childItemProject) {
                              const childProjectItem = childItemProject.items.nodes.find(i =>
                                i.content && i.content.id === childIssue.data.node_id
                              );

                              if (childProjectItem) {
                                // Set Type based on title
                                const childTitle = childIssue.data.title;
                                let childType = null;
                                if (childTitle.startsWith('[EPIC]')) childType = 'Epic';
                                else if (childTitle.startsWith('[FEATURE]')) childType = 'Feature';
                                else if (childTitle.startsWith('[STORY]')) childType = 'User Story';
                                else if (childTitle.startsWith('[TASK]') || childTitle.startsWith('[Task]')) childType = 'Task';

                                if (childType) {
                                  const typeField = childItemProject.fields.nodes.find(f => f.name === 'Type');
                                  if (typeField) {
                                    const typeOption = typeField.options.find(o => o.name === childType);
                                    if (typeOption) {
                                      const updateTypeMutation = `
                                        mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: ProjectV2FieldValue!) {
                                          updateProjectV2ItemFieldValue(input: {
                                            projectId: $projectId
                                            itemId: $itemId
                                            fieldId: $fieldId
                                            value: $value
                                          }) {
                                            projectV2Item { id }
                                          }
                                        }
                                      `;

                                      await github.graphql(updateTypeMutation, {
                                        projectId: childItemProject.id,
                                        itemId: childProjectItem.id,
                                        fieldId: typeField.id,
                                        value: { singleSelectOptionId: typeOption.id }
                                      });

                                      console.log(`  ‚úÖ Set Type to "${childType}" for ${repoLabel}`);
                                    }
                                  }
                                }

                                // Get parent's iteration
                                const parentIterationQuery = `
                                  query($owner: String!) {
                                    organization(login: $owner) {
                                      projectsV2(first: 10) {
                                        nodes {
                                          title
                                          items(first: 100) {
                                            nodes {
                                              content {
                                                ... on Issue {
                                                  number
                                                }
                                              }
                                              fieldValues(first: 20) {
                                                nodes {
                                                  ... on ProjectV2ItemFieldIterationValue {
                                                    title
                                                    iterationId
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                `;

                                const parentIterResult = await github.graphql(parentIterationQuery, {
                                  owner: context.repo.owner
                                });

                                const parentIterProject = parentIterResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                                if (parentIterProject) {
                                  const parentItem = parentIterProject.items.nodes.find(i =>
                                    i.content && i.content.number === issueNumber
                                  );

                                  if (parentItem) {
                                    const iterationValue = parentItem.fieldValues.nodes.find(fv => fv.iterationId);

                                    if (iterationValue) {
                                      console.log('  üìÖ Parent has iteration: ' + iterationValue.title);

                                      const iterationField = childItemProject.fields.nodes.find(f => f.name === 'Iteration');

                                      if (iterationField) {
                                        const setIterationMutation = `
                                          mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $iterationId: String!) {
                                            updateProjectV2ItemFieldValue(input: {
                                              projectId: $projectId
                                              itemId: $itemId
                                              fieldId: $fieldId
                                              value: { iterationId: $iterationId }
                                            }) {
                                              projectV2Item { id }
                                            }
                                          }
                                        `;

                                        await github.graphql(setIterationMutation, {
                                          projectId: childItemProject.id,
                                          itemId: childProjectItem.id,
                                          fieldId: iterationField.id,
                                          iterationId: iterationValue.iterationId
                                        });

                                        console.log('  ‚úÖ Inherited iteration "' + iterationValue.title + '" from parent');
                                      }
                                    } else {
                                      console.log('  ‚ÑπÔ∏è  Parent has no iteration set');
                                    }
                                  }
                                }
                              }
                            }
                          } catch (iterError) {
                            console.log('  ‚ö†Ô∏è  Could not inherit iteration: ' + iterError.message);
                          }
                        }
                      }

                    } catch (error) {
                      if (error.status === 410) {
                        console.log(`  ‚ö†Ô∏è  ${repoLabel} was deleted, skipping`);
                      } else if (error.status === 404) {
                        console.log(`  ‚ö†Ô∏è  ${repoLabel} not found or not accessible, skipping`);
                      } else {
                        console.log(`  ‚ùå Error processing ${repoLabel}: ${error.message}`);
                      }
                    }
                  }
                }
              } catch (error) {
                console.log(`‚ö†Ô∏è  Error checking for new children: ${error.message}`);
              }

              // Recursively set types for all descendants
              console.log(`\nüè∑Ô∏è  Checking types for all descendants...`);
              try {
                await updateDescendantsTypes(issueNumber);
              } catch (error) {
                console.log(`‚ö†Ô∏è  Error updating descendant types: ${error.message}`);
              }

              // Recursively set iterations for all descendants
              console.log(`\nüìÖ Checking iterations for all descendants...`);
              try {
                await updateDescendantsIterations(issueNumber);
              } catch (error) {
                console.log(`‚ö†Ô∏è  Error updating descendant iterations: ${error.message}`);
              }
            }

            // ========================================
            // Cascade milestone updates to all descendants
            // ========================================
            const currentMilestone = context.payload.issue.milestone;

            let updatedDescendants = new Set();
            if (['milestoned', 'demilestoned', 'edited'].includes(actionType) || runFullSync) {
              console.log(`\nüîÑ Cascading milestone changes to all descendants of #${issueNumber}...`);
              updatedDescendants = await updateDescendantsMilestone(issueNumber, currentMilestone);

              if (updatedDescendants.size > 0) {
                console.log(`‚úÖ Updated ${updatedDescendants.size} descendant issue(s) with milestone "${currentMilestone?.title || 'none'}"`);
              } else {
                console.log('‚ÑπÔ∏è  No descendants found or all already up-to-date');
              }
            }

            // ========================================
            // Cascade label changes to all descendants
            // ========================================

            if (['labeled', 'unlabeled'].includes(actionType)) {
              console.log(`\nüè∑Ô∏è  Cascading label changes to all descendants of #${issueNumber}...`);

              let labelOperation = '';
              let labelName = '';

              if (actionType === 'labeled') {
                labelOperation = 'add';
                labelName = context.payload.label.name;
                console.log(`Label "${labelName}" was added to parent #${issueNumber}`);
              } else if (actionType === 'unlabeled') {
                labelOperation = 'remove';
                labelName = context.payload.label.name;
                console.log(`Label "${labelName}" was removed from parent #${issueNumber}`);
              }

              // Skip cascading the 'sync' label (it's only for triggering)
              if (labelName === 'sync') {
                console.log('‚ÑπÔ∏è  Skipping cascade of "sync" label (trigger label only)');
                labelName = '';
              }

              if (labelName) {
                const updatedDescendantsLabels = await updateDescendantsLabels(issueNumber, labelName, labelOperation);

                if (updatedDescendantsLabels.size > 0) {
                  console.log(`‚úÖ ${labelOperation === 'add' ? 'Added' : 'Removed'} label "${labelName}" ${labelOperation === 'add' ? 'to' : 'from'} ${updatedDescendantsLabels.size} descendant issue(s)`);
                } else {
                  console.log('‚ÑπÔ∏è  No descendants found or all already up-to-date');
                }
              }
            }

            // Create comment summarizing automation actions

            // ========================================
            // Auto-Close/Reopen Parent Issues
            // ========================================

            if (actionType === 'closed' || actionType === 'reopened') {
              // First: If this issue was closed, close all its descendants
              if (actionType === 'closed') {
                console.log(`\nüîí Parent issue #${issueNumber} closed - closing all descendants...`);
                const closedDescendants = await closeAllDescendants(issueNumber);
                if (closedDescendants.size > 0) {
                  console.log(`‚úÖ Closed ${closedDescendants.size} descendant issue(s)`);
                } else {
                  console.log('‚ÑπÔ∏è  No open descendants to close');
                }
              }

              // Second: Sync parent state based on children state
              console.log(`\nüîÑ Issue #${issueNumber} was ${actionType}, syncing parent state...`);

              // Function to sync parent state based on all children
              async function syncParentState(childIssueNumber, depth = 0) {
                const indent = '  '.repeat(depth);

                // Get the child issue to find its parent
                const childIssue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: childIssueNumber
                });

                const childBody = childIssue.data.body || '';
                const bodyWithoutComments = childBody.replace(/<!--[\s\S]*?-->/g, '');
                const parentMatch = bodyWithoutComments.match(/(?:Epic|Feature|Parent Feature|Parent Epic):\s*#(\d+)/i);

                if (!parentMatch) {
                  console.log(`${indent}‚ÑπÔ∏è  Issue #${childIssueNumber} has no parent reference`);
                  return;
                }

                const parentNumber = parseInt(parentMatch[1]);
                console.log(`${indent}üìã Found parent: #${parentNumber}`);

                // Get parent issue
                let parentIssue;
                try {
                  parentIssue = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber
                  });
                } catch (error) {
                  console.log(`${indent}‚ö†Ô∏è  Parent issue #${parentNumber} not found: ${error.message}`);
                  return;
                }

                // Find all children of this parent
                const allChildren = await findChildIssues(parentNumber);

                if (allChildren.length === 0) {
                  console.log(`${indent}‚ÑπÔ∏è  Parent #${parentNumber} has no children (relationship may be inconsistent)`);
                  return;
                }

                // Check if all children are closed
                const allClosed = allChildren.every(child => child.state === 'closed');
                const anyClosed = allChildren.some(child => child.state === 'closed');
                const anyOpen = allChildren.some(child => child.state === 'open');

                console.log(`${indent}üìä Parent #${parentNumber} status: ${allChildren.length} children, ${allChildren.filter(c => c.state === 'closed').length} closed, ${allChildren.filter(c => c.state === 'open').length} open`);

                const parentState = parentIssue.data.state;
                let actionTaken = false;

                // If all children closed and parent is open ‚Üí close parent
                if (allClosed && parentState === 'open') {
                  console.log(`${indent}‚úÖ All children closed, closing parent #${parentNumber}`);

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber,
                    state: 'closed',
                    state_reason: 'completed'
                  });


                  actionTaken = true;
                }

                // If any child open and parent is closed ‚Üí reopen parent
                if (anyOpen && parentState === 'closed') {
                  console.log(`${indent}üîì Child reopened, reopening parent #${parentNumber}`);

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber,
                    state: 'open'
                  });

                  const openChildren = allChildren.filter(c => c.state === 'open');

                  actionTaken = true;
                }

                if (!actionTaken) {
                  console.log(`${indent}‚è≠Ô∏è  Parent #${parentNumber} already in correct state (${parentState})`);
                }

                // Recursively sync grandparent
                await syncParentState(parentNumber, depth + 1);
              }

              // Start the sync chain from this issue
              await syncParentState(issueNumber);
              console.log('‚úÖ Parent state sync complete!');
            }

            // ========================================
            // Rollup estimates to parent (automatic)
            // ========================================

            if (actionType === 'edited' || runFullSync) {
              console.log('\nüìä Checking if estimates need to be rolled up to parent...');

              try {
                const parent = await findParentIssue(issueNumber);

                if (parent && parent.number) {
                  console.log(`Found parent issue #${parent.number}, rolling up estimates...`);

                  // Get all children of the parent (including this issue)
                  const parentChildren = await findChildIssues(parent.number);

                  if (parentChildren && parentChildren.length > 0) {
                    let totalEstimate = 0;
                    let totalRemaining = 0;

                    console.log(`Parent #${parent.number} has ${parentChildren.length} children, calculating totals...`);

                    for (const child of parentChildren) {
                      const childOwner = child.repository?.owner?.login || context.repo.owner;
                      const childRepo = child.repository?.name || context.repo.repo;
                      const childNumber = child.number;

                      try {
                        // Get child's project fields
                        const childProjectQuery = `
                          query($owner: String!) {
                            organization(login: $owner) {
                              projectsV2(first: 10) {
                                nodes {
                                  id
                                  title
                                  items(first: 100) {
                                    nodes {
                                      id
                                      content {
                                        ... on Issue {
                                          id
                                          number
                                          repository {
                                            name
                                            owner {
                                              login
                                            }
                                          }
                                        }
                                      }
                                      fieldValues(first: 20) {
                                        nodes {
                                          ... on ProjectV2ItemFieldNumberValue {
                                            number
                                            field {
                                              ... on ProjectV2Field {
                                                id
                                                name
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        `;

                        const childProjResult = await github.graphql(childProjectQuery, {
                          owner: context.repo.owner
                        });

                        const childProject = childProjResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                        if (childProject) {
                          const childItem = childProject.items.nodes.find(i => {
                            if (!i.content) return false;
                            const itemOwner = i.content.repository?.owner?.login || context.repo.owner;
                            const itemRepo = i.content.repository?.name || context.repo.repo;
                            return i.content.number === childNumber && itemOwner === childOwner && itemRepo === childRepo;
                          });

                          if (childItem) {
                            const estimateField = childItem.fieldValues.nodes.find(fv => fv.field && fv.field.name === 'Estimate');
                            const remainingField = childItem.fieldValues.nodes.find(fv => fv.field && fv.field.name === 'Remaining');

                            const estimate = estimateField?.number || 0;
                            const remaining = remainingField?.number || 0;

                            totalEstimate += estimate;
                            totalRemaining += remaining;

                            const childLabel = (childRepo !== context.repo.repo || childOwner !== context.repo.owner) ? `${childOwner}/${childRepo}#${childNumber}` : `#${childNumber}`;
                            console.log(`  ${childLabel}: Estimate=${estimate}, Remaining=${remaining}`);
                          }
                        }
                      } catch (childError) {
                        console.log(`  ‚ö†Ô∏è  Could not get estimates for child #${childNumber}: ${childError.message}`);
                      }
                    }

                    console.log(`üìä Total from ${parentChildren.length} children: Estimate=${totalEstimate}, Remaining=${totalRemaining}`);

                    // Update parent's fields
                    try {
                      const parentProjectQuery = `
                        query($owner: String!) {
                          organization(login: $owner) {
                            projectsV2(first: 10) {
                              nodes {
                                id
                                title
                                items(first: 100) {
                                  nodes {
                                    id
                                    content {
                                      ... on Issue {
                                        id
                                        number
                                      }
                                    }
                                  }
                                }
                                fields(first: 20) {
                                  nodes {
                                    ... on ProjectV2Field {
                                      id
                                      name
                                      dataType
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      `;

                      const parentProjResult = await github.graphql(parentProjectQuery, {
                        owner: context.repo.owner
                      });

                      const parentProject = parentProjResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                      if (parentProject) {
                        const parentItem = parentProject.items.nodes.find(i =>
                          i.content && i.content.number === parent.number
                        );

                        if (parentItem) {
                          const estimateField = parentProject.fields.nodes.find(f => f.name === 'Estimate');
                          const remainingField = parentProject.fields.nodes.find(f => f.name === 'Remaining');

                          if (estimateField && remainingField) {
                            // Update Estimate
                            const updateEstimateMutation = `
                              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: Float!) {
                                updateProjectV2ItemFieldValue(input: {
                                  projectId: $projectId
                                  itemId: $itemId
                                  fieldId: $fieldId
                                  value: { number: $value }
                                }) {
                                  projectV2Item { id }
                                }
                              }
                            `;

                            await github.graphql(updateEstimateMutation, {
                              projectId: parentProject.id,
                              itemId: parentItem.id,
                              fieldId: estimateField.id,
                              value: totalEstimate
                            });

                            console.log(`‚úÖ Updated parent #${parent.number} Estimate to ${totalEstimate}`);

                            // Update Remaining
                            await github.graphql(updateEstimateMutation, {
                              projectId: parentProject.id,
                              itemId: parentItem.id,
                              fieldId: remainingField.id,
                              value: totalRemaining
                            });

                            console.log(`‚úÖ Updated parent #${parent.number} Remaining to ${totalRemaining}`);
                          }
                        }
                      }
                    } catch (updateError) {
                      console.log(`‚ö†Ô∏è  Could not update parent estimates: ${updateError.message}`);
                    }
                  }
                } else {
                  console.log('‚ÑπÔ∏è  No parent issue found, skipping rollup');
                }
              } catch (error) {
                console.log(`‚ö†Ô∏è  Error during rollup: ${error.message}`);
              }
            }

            // ========================================
            // Remove 'sync' label after processing
            // ========================================

            if (runFullSync) {
              console.log('\nüßπ Removing "sync" label after full synchronization...');
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  name: 'sync'
                });
                console.log('‚úÖ "sync" label removed');
              } catch (error) {
                console.log('‚ö†Ô∏è  Could not remove "sync" label: ' + error.message);
              }
            }
