name: Issue Automation

on:
  issues:
    types: [opened, edited, reopened, closed, milestoned, demilestoned, assigned, unassigned, labeled, unlabeled]

jobs:
  automate-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      repository-projects: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @octokit/graphql

      - name: Auto-set Type and Inherit Milestone
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_WITH_PROJECT_ACCESS || secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = context.issue.number;
            const issueBody = context.payload.issue.body || '';
            const issueTitle = context.payload.issue.title || '';

            // Function to find all child issues (issues that reference this issue as parent)
            async function findChildIssues(parentNumber) {
              console.log(`üîç Looking for children of issue #${parentNumber}...`);

              // Method 1: Check GitHub's native sub-issues
              try {
                const graphqlQuery = `
                  query($owner: String!, $repo: String!, $issueNumber: Int!) {
                    repository(owner: $owner, name: $repo) {
                      issue(number: $issueNumber) {
                        trackedIssues(first: 100) {
                          nodes {
                            number
                            title
                            state
                            milestone {
                              number
                              title
                            }
                            body
                          }
                        }
                      }
                    }
                  }
                `;

                const result = await github.graphql(graphqlQuery, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issueNumber: parentNumber
                });

                const trackedChildren = result.repository.issue.trackedIssues.nodes;
                if (trackedChildren.length > 0) {
                  console.log(`‚úÖ Found ${trackedChildren.length} child issue(s) via native sub-issues`);
                  return trackedChildren;
                }
              } catch (error) {
                console.log(`‚ö†Ô∏è  Could not query native sub-issues: ${error.message}`);
              }

              // Method 2: Fall back to description parsing
              console.log('üîÑ Falling back to description parsing...');
              const allIssues = [];
              let page = 1;
              let hasMore = true;

              while (hasMore) {
                const issues = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  per_page: 100,
                  page: page
                });

                if (issues.data.length === 0) {
                  hasMore = false;
                } else {
                  allIssues.push(...issues.data);
                  page++;
                }
              }

              const children = allIssues.filter(issue => {
                const body = issue.body || '';
                const bodyWithoutComments = body.replace(/<!--[\s\S]*?-->/g, '');
                const parentPattern = new RegExp(`(?:Epic|Feature|Parent Feature|Parent Epic):\\s*#${parentNumber}(?:\\s|$)`, 'i');
                return parentPattern.test(bodyWithoutComments);
              });

              console.log(`Found ${children.length} child issue(s) via description parsing`);
              return children;
            }

              // Method 2: Fall back to description parsing
              console.log('üîÑ Falling back to description parsing...');
              const allIssues = [];
              let page = 1;
              let hasMore = true;

              while (hasMore) {
                const issues = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  per_page: 100,
                  page: page
                });

                if (issues.data.length === 0) {
                  hasMore = false;
                } else {
                  allIssues.push(...issues.data);
                  page++;
                }
              }

              const children = allIssues.filter(issue => {
                const body = issue.body || '';
                const bodyWithoutComments = body.replace(/<!--[\s\S]*?-->/g, '');
                const parentPattern = new RegExp(`(?:Epic|Feature|Parent Feature|Parent Epic):\\s*#${parentNumber}(?:\\s|$)`, 'i');
                return parentPattern.test(bodyWithoutComments);
              });

              console.log(`Found ${children.length} child issue(s) via description parsing`);
              return children;
            }

              // Method 2: Fall back to description parsing
              console.log('üîÑ Falling back to description parsing...');
              const allIssues = [];
              let page = 1;
              let hasMore = true;

              while (hasMore) {
                const issues = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  per_page: 100,
                  page: page
                });

                if (issues.data.length === 0) {
                  hasMore = false;
                } else {
                  allIssues.push(...issues.data);
                  page++;
                }
              }

              const children = allIssues.filter(issue => {
                const body = issue.body || '';
                const bodyWithoutComments = body.replace(/<!--[\s\S]*?-->/g, '');
                const parentPattern = new RegExp(`(?:Epic|Feature|Parent Feature|Parent Epic):\\s*#${parentNumber}(?:\\s|$)`, 'i');
                return parentPattern.test(bodyWithoutComments);
              });

              console.log(`Found ${children.length} child issue(s) via description parsing`);
              return children;
            }

              // Filter issues that reference this issue as parent
              const children = allIssues.filter(issue => {
                const body = issue.body || '';
                // Remove HTML comments to avoid matching examples
                const bodyWithoutComments = body.replace(/<!--[\s\S]*?-->/g, '');
                const parentPattern = new RegExp(`(?:Epic|Feature|Parent Feature|Parent Epic):\\s*#${parentNumber}(?:\\s|$)`, 'i');
                return parentPattern.test(bodyWithoutComments);
              });

              console.log(`Found ${children.length} child issue(s) of #${parentNumber}`);
              return children;
            }

            // Function to recursively update all descendants with milestone
            async function updateDescendantsMilestone(parentNumber, milestone, depth = 0, updatedIssues = new Set()) {
              const indent = '  '.repeat(depth);
              console.log(`${indent}Checking descendants of #${parentNumber}...`);

              const children = await findChildIssues(parentNumber);

              for (const child of children) {
                // Avoid infinite loops
                if (updatedIssues.has(child.number)) {
                  console.log(`${indent}‚è≠Ô∏è  Skipping #${child.number} (already processed)`);
                  continue;
                }

                updatedIssues.add(child.number);

                const currentMilestone = child.milestone ? child.milestone.number : null;
                const targetMilestone = milestone ? milestone.number : null;

                if (currentMilestone !== targetMilestone) {
                  console.log(`${indent}üìù Updating #${child.number} milestone from "${child.milestone?.title || 'none'}" to "${milestone?.title || 'none'}"`);

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: child.number,
                    milestone: targetMilestone
                  });

                  console.log(`${indent}‚úÖ Updated #${child.number}`);
                } else {
                  console.log(`${indent}‚è≠Ô∏è  #${child.number} already has correct milestone`);
                }

                // Recursively update grandchildren
                await updateDescendantsMilestone(child.number, milestone, depth + 1, updatedIssues);
              }

              return updatedIssues;
            }

            // Determine issue type from title prefix
            let issueType = null;
            if (issueTitle.startsWith('[EPIC]')) {
              issueType = 'Epic';
            } else if (issueTitle.startsWith('[FEATURE]')) {
              issueType = 'Feature';
            } else if (issueTitle.startsWith('[STORY]')) {
              issueType = 'User Story';
            } else if (issueTitle.startsWith('[Task]')) {
              issueType = 'Task';
            }

                        console.log(`Issue #${issueNumber}: Type detected as "${issueType}"`);

            // Function to find parent issue using GitHub's native relationships
            async function findParentIssue(issueNum) {
              console.log(`üîç Looking for parent of issue #${issueNum}...`);

              // Method 1: Check GitHub's native sub-issues (trackedInIssues)
              try {
                const graphqlQuery = `
                  query($owner: String!, $repo: String!, $issueNumber: Int!) {
                    repository(owner: $owner, name: $repo) {
                      issue(number: $issueNumber) {
                        number
                        trackedInIssues(first: 1) {
                          nodes {
                            number
                            title
                            milestone {
                              number
                              title
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const result = await github.graphql(graphqlQuery, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issueNumber: issueNum
                });

                const parent = result.repository.issue.trackedInIssues.nodes[0];
                if (parent) {
                  console.log(`‚úÖ Parent found via sub-issues: #${parent.number} (${parent.title})`);
                  return {
                    number: parent.number,
                    milestone: parent.milestone
                  };
                }
              } catch (error) {
                console.log(`‚ö†Ô∏è  Could not query sub-issues: ${error.message}`);
              }

              // Method 2: Fall back to description parsing
              console.log('Checking issue description for parent reference...');
              const issue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNum
              });

              const bodyWithoutComments = (issue.data.body || '').replace(/<!--[\s\S]*?-->/g, '');
              const parentMatch = bodyWithoutComments.match(/(?:Epic|Feature|Parent Feature|Parent Epic):\s*#(\d+)/i);

              if (parentMatch) {
                const parentNum = parseInt(parentMatch[1]);
                console.log(`‚úÖ Parent found via description: #${parentNum}`);

                const parentIssue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parentNum
                });

                return {
                  number: parentNum,
                  milestone: parentIssue.data.milestone,
                  labels: parentIssue.data.labels || []
                };
              }

              console.log('‚ÑπÔ∏è  No parent issue found');
              return null;
            }

            // Find parent issue
            let parentIssueNumber = null;
            let parentMilestone = null;

            try {
              const parent = await findParentIssue(issueNumber);
              if (parent) {
                parentIssueNumber = parent.number;
                parentMilestone = parent.milestone;

                if (parentMilestone) {
                  console.log(`Parent milestone found: ${parentMilestone.title}`);

                  // Set milestone on current issue
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    milestone: parentMilestone.number
                  });

                  console.log(`‚úÖ Milestone "${parentMilestone.title}" inherited from parent issue #${parentIssueNumber}`);
                } else {
                  console.log('Parent issue has no milestone set');
                }

                // Inherit labels from parent
                if (parent.labels && parent.labels.length > 0) {
                  const labelNames = parent.labels.map(l => l.name);
                  console.log(`Inheriting ${labelNames.length} labels from parent: ${labelNames.join(', ')}`);

                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      labels: labelNames
                    });
                    console.log(`‚úÖ Inherited ${labelNames.length} labels from parent`);
                  } catch (error) {
                    console.error(`Error inheriting labels:`, error.message);
                  }
                } else {
                  console.log('Parent issue has no labels to inherit');
                }
              }
            } catch (error) {
              console.error(`Error finding parent issue:`, error.message);
            }

            // Set GitHub Issue Type field (organizational issue type)
            if (issueType) {
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  type: issueType
                });
                console.log(`‚úÖ Issue Type set to "${issueType}"`);
              } catch (error) {
                console.error('Error setting issue type:', error.message);
                console.log('‚ö†Ô∏è  Note: Issue types require push access and must be configured in your organization');
                console.log('‚ö†Ô∏è  Available types can be checked with: gh api orgs/:org/issue-types');
              }
            }

            // Set project field (Type) using GraphQL
            let childProjectId = null;
            let childItemId = null;
            let childProjectFields = null;

            if (issueType) {
              try {
                // Get the issue node ID
                const issueData = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                const issueNodeId = issueData.data.node_id;

                // Find projects associated with this repository (organization-level)
                const projectsQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          fields(first: 20) {
                            nodes {
                              ... on ProjectV2SingleSelectField {
                                id
                                name
                                options {
                                  id
                                  name
                                }
                              }
                              ... on ProjectV2IterationField {
                                id
                                name
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const projectsResult = await github.graphql(projectsQuery, {
                  owner: context.repo.owner
                });

                const projects = projectsResult.organization.projectsV2.nodes;
                console.log(`Found ${projects.length} project(s)`);

                // Find the specific project "[TEMPLATE] EngageMe"
                const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

                if (!project) {
                  console.log('‚ö†Ô∏è  [TEMPLATE] EngageMe project not found');
                } else {
                  console.log(`Processing project: ${project.title}`);

                  // Store project info for later use (iteration inheritance)
                  childProjectId = project.id;
                  childProjectFields = project.fields.nodes;

                  // Add issue to project first
                  const addToProjectMutation = `
                    mutation($projectId: ID!, $contentId: ID!) {
                      addProjectV2ItemById(input: {
                        projectId: $projectId
                        contentId: $contentId
                      }) {
                        item {
                          id
                        }
                      }
                    }
                  `;

                  let itemId;
                  try {
                    const addResult = await github.graphql(addToProjectMutation, {
                      projectId: project.id,
                      contentId: issueNodeId
                    });
                    itemId = addResult.addProjectV2ItemById.item.id;
                    childItemId = itemId;  // Store for iteration inheritance
                    console.log(`‚úÖ Issue added to project with item ID: ${itemId}`);
                  } catch (error) {
                    console.log(`Issue might already be in project: ${error.message}`);
                    // If already in project, we need to find the item ID
                    // Try to find it in the project items
                    const projectQuery = `
                      query($owner: String!) {
                        organization(login: $owner) {
                          projectsV2(first: 10) {
                            nodes {
                              id
                              title
                              items(first: 100) {
                                nodes {
                                  id
                                  content {
                                    ... on Issue {
                                      number
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const projectResult = await github.graphql(projectQuery, {
                      owner: context.repo.owner
                    });

                    const targetProject = projectResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                    if (targetProject) {
                      const item = targetProject.items.nodes.find(i => i.content && i.content.number === issueNumber);
                      if (item) {
                        itemId = item.id;
                        childItemId = itemId;  // Store for iteration inheritance
                        console.log(`‚úÖ Found existing item ID: ${itemId}`);
                      }
                    }
                  }

                  if (!itemId) {
                    console.log('‚ö†Ô∏è  Could not get item ID, skipping project field update');
                  } else {
                    // Find the Type field
                    const typeField = project.fields.nodes.find(field =>
                      field.name === 'Type' && field.options
                    );

                    if (typeField) {
                      console.log(`Found Type field with ID: ${typeField.id}`);

                      // Find the matching option
                      const typeOption = typeField.options.find(opt =>
                        opt.name === issueType
                      );

                      if (typeOption) {
                        console.log(`Found matching type option: ${typeOption.name} (${typeOption.id})`);

                        // Update the field value
                        const updateFieldMutation = `
                          mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                            updateProjectV2ItemFieldValue(input: {
                              projectId: $projectId
                              itemId: $itemId
                              fieldId: $fieldId
                              value: {
                                singleSelectOptionId: $optionId
                              }
                            }) {
                              projectV2Item {
                                id
                              }
                            }
                          }
                        `;

                        await github.graphql(updateFieldMutation, {
                          projectId: project.id,
                          itemId: itemId,
                          fieldId: typeField.id,
                          optionId: typeOption.id
                        });

                        console.log(`‚úÖ Type field set to "${issueType}" in project "${project.title}"`);
                      } else {
                        console.log(`‚ö†Ô∏è Type option "${issueType}" not found in project field. Available options: ${typeField.options.map(o => o.name).join(', ')}`);
                      }
                    } else {
                      console.log('‚ö†Ô∏è Type field not found in project. Please create a single-select field named "Type" with options: Epic, Feature, User Story, Task');
                    }
                  }
                }
              } catch (error) {
                console.error('Error setting project field:', error.message);
                if (error.errors) {
                  console.error('GraphQL errors:', JSON.stringify(error.errors, null, 2));
                }
              }
            }

            // ========================================
            // Inherit iteration from parent (works for ALL issues with a parent)
            // ========================================

            if (parentIssueNumber) {
              console.log(`\nüìÖ Checking for parent iteration...`);

              try {
                // Get child's project info (needed for iteration inheritance)
                const childIssueData = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                const childIssueNodeId = childIssueData.data.node_id;

                // Find child's project item
                const childProjectQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          items(first: 100) {
                            nodes {
                              id
                              content {
                                ... on Issue {
                                  id
                                  number
                                }
                              }
                            }
                          }
                          fields(first: 20) {
                            nodes {
                              ... on ProjectV2IterationField {
                                id
                                name
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const childProjectResult = await github.graphql(childProjectQuery, {
                  owner: context.repo.owner
                });

                const childProjects = childProjectResult.organization.projectsV2.nodes;
                const childProject = childProjects.find(p => p.title === '[TEMPLATE] EngageMe');

                if (!childProject) {
                  console.log('Child issue not in project yet, skipping iteration inheritance');
                } else {
                  const childItem = childProject.items.nodes.find(i =>
                    i.content && i.content.number === issueNumber
                  );

                  if (!childItem) {
                    console.log('Child issue not found in project items, skipping iteration inheritance');
                  } else {
                    const childProjectId = childProject.id;
                    const childItemId = childItem.id;
                    const childProjectFields = childProject.fields.nodes;

                    console.log('Child issue found in project, proceeding with iteration inheritance');

                // Function to get iteration for parent issue
                async function getParentIteration(issueNum) {
                  const projectQuery = `
                    query($owner: String!) {
                      organization(login: $owner) {
                        projectsV2(first: 10) {
                          nodes {
                            id
                            title
                            items(first: 100) {
                              nodes {
                                id
                                content {
                                  ... on Issue {
                                    number
                                  }
                                }
                                fieldValues(first: 20) {
                                  nodes {
                                    ... on ProjectV2ItemFieldIterationValue {
                                      title
                                      iterationId
                                      field {
                                        ... on ProjectV2IterationField {
                                          id
                                          name
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  `;

                  const result = await github.graphql(projectQuery, {
                    owner: context.repo.owner
                  });

                  const projects = result.organization.projectsV2.nodes;
                  const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

                  if (!project) return null;

                  const item = project.items.nodes.find(i => i.content && i.content.number === issueNum);
                  if (!item) return null;

                  const iterationValue = item.fieldValues.nodes.find(fv =>
                    fv.field && fv.field.name === 'Iteration' && fv.iterationId
                  );

                  if (!iterationValue) return null;

                  return {
                    id: iterationValue.iterationId,
                    title: iterationValue.title
                  };
                }

                    // Get parent's iteration
                    const parentIteration = await getParentIteration(parentIssueNumber);

                    if (parentIteration) {
                      console.log(`Parent iteration found: ${parentIteration.title}`);

                      // Find iteration field ID from child project fields
                      const iterationField = childProjectFields.find(f => f.name === 'Iteration');

                      if (iterationField && iterationField.id) {
                        // Set iteration on child issue
                        const updateIterationMutation = `
                          mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $iterationId: String!) {
                            updateProjectV2ItemFieldValue(input: {
                              projectId: $projectId
                              itemId: $itemId
                              fieldId: $fieldId
                              value: {
                                iterationId: $iterationId
                              }
                            }) {
                              projectV2Item {
                                id
                              }
                            }
                          }
                        `;

                        await github.graphql(updateIterationMutation, {
                          projectId: childProjectId,
                          itemId: childItemId,
                          fieldId: iterationField.id,
                          iterationId: parentIteration.id
                        });

                        console.log(`‚úÖ Iteration "${parentIteration.title}" inherited from parent issue #${parentIssueNumber}`);
                      } else {
                        console.log('‚ö†Ô∏è  Iteration field not found in project');
                      }
                    } else {
                      console.log('Parent issue has no iteration set');
                    }
                  }
                }
              } catch (error) {
                console.error(`Error inheriting iteration:`, error.message);
              }
            }

            // ========================================
            // Validation: Estimate Required for In Progress
            // ========================================

            if (issueType === 'Task' || issueType === 'User Story') {
              console.log(`\nüîç Validating estimate for ${issueType}...`);

              try {
                // Get project fields including Status and Estimate
                const issueData = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                const issueNodeId = issueData.data.node_id;

                // Query project for Status and Estimate fields
                const projectQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          items(first: 100) {
                            nodes {
                              id
                              content {
                                ... on Issue {
                                  id
                                  number
                                }
                              }
                              fieldValues(first: 20) {
                                nodes {
                                  ... on ProjectV2ItemFieldNumberValue {
                                    number
                                    field {
                                      ... on ProjectV2Field {
                                        id
                                        name
                                      }
                                    }
                                  }
                                  ... on ProjectV2ItemFieldSingleSelectValue {
                                    name
                                    field {
                                      ... on ProjectV2SingleSelectField {
                                        id
                                        name
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const projectResult = await github.graphql(projectQuery, {
                  owner: context.repo.owner
                });

                const projects = projectResult.organization.projectsV2.nodes;
                const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

                if (project) {
                  const item = project.items.nodes.find(i => i.content && i.content.number === issueNumber);

                  if (item) {
                    // Extract Status and Estimate values
                    let statusValue = null;
                    let estimateValue = 0;

                    item.fieldValues.nodes.forEach(fv => {
                      if (fv.field) {
                        if (fv.field.name === 'Status' && fv.name) {
                          statusValue = fv.name;
                        }
                        if (fv.field.name === 'Estimate' && fv.number !== undefined) {
                          estimateValue = fv.number;
                        }
                      }
                    });

                    console.log(`üìä Status: "${statusValue}", Estimate: ${estimateValue}`);

                    // Validation: If Status is "In Progress" and Estimate is 0, add warning
                    if (statusValue === 'In Progress' && estimateValue === 0) {
                      console.log('‚ö†Ô∏è  Validation failed: In Progress without estimate');

                      // Add label
                      await github.rest.issues.addLabels({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        labels: ['needs-estimate']
                      });


                      console.log('‚úÖ Added needs-estimate label and warning comment');
                    } else if (statusValue === 'In Progress' && estimateValue > 0) {
                      // Remove label if estimate is now set
                      try {
                        await github.rest.issues.removeLabel({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber,
                          name: 'needs-estimate'
                        });
                        console.log('‚úÖ Removed needs-estimate label (estimate now set)');
                      } catch (error) {
                        // Label might not exist, ignore error
                      }
                    } else {
                      console.log('‚úÖ Validation passed');
                    }
                  } else {
                    console.log('‚ÑπÔ∏è  Issue not found in project, skipping validation');
                  }
                } else {
                  console.log('‚ÑπÔ∏è  [TEMPLATE] EngageMe project not found, skipping validation');
                }
              } catch (error) {
                console.error('Error during validation:', error.message);
              }
            }

            // Cascade milestone updates to all descendants
            const currentMilestone = context.payload.issue.milestone;
            const actionType = context.payload.action;

            let updatedDescendants = new Set();
            if (['milestoned', 'demilestoned', 'edited'].includes(actionType)) {
              console.log(`\nüîÑ Cascading milestone changes to all descendants of #${issueNumber}...`);
              updatedDescendants = await updateDescendantsMilestone(issueNumber, currentMilestone);

              if (updatedDescendants.size > 0) {
                console.log(`‚úÖ Updated ${updatedDescendants.size} descendant issue(s) with milestone "${currentMilestone?.title || 'none'}"`);
              } else {
                console.log('‚ÑπÔ∏è  No descendants found or all already up-to-date');
              }
            }

            // Create comment summarizing automation actions

            // ========================================
            // Auto-Close/Reopen Parent Issues
            // ========================================

            if (actionType === 'closed' || actionType === 'reopened') {
              console.log(`\nüîÑ Issue #${issueNumber} was ${actionType}, syncing parent state...`);

              // Function to sync parent state based on all children
              async function syncParentState(childIssueNumber, depth = 0) {
                const indent = '  '.repeat(depth);

                // Get the child issue to find its parent
                const childIssue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: childIssueNumber
                });

                const childBody = childIssue.data.body || '';
                const bodyWithoutComments = childBody.replace(/<!--[\s\S]*?-->/g, '');
                const parentMatch = bodyWithoutComments.match(/(?:Epic|Feature|Parent Feature|Parent Epic):\s*#(\d+)/i);

                if (!parentMatch) {
                  console.log(`${indent}‚ÑπÔ∏è  Issue #${childIssueNumber} has no parent reference`);
                  return;
                }

                const parentNumber = parseInt(parentMatch[1]);
                console.log(`${indent}üìã Found parent: #${parentNumber}`);

                // Get parent issue
                let parentIssue;
                try {
                  parentIssue = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber
                  });
                } catch (error) {
                  console.log(`${indent}‚ö†Ô∏è  Parent issue #${parentNumber} not found: ${error.message}`);
                  return;
                }

                // Find all children of this parent
                const allChildren = await findChildIssues(parentNumber);

                if (allChildren.length === 0) {
                  console.log(`${indent}‚ÑπÔ∏è  Parent #${parentNumber} has no children (relationship may be inconsistent)`);
                  return;
                }

                // Check if all children are closed
                const allClosed = allChildren.every(child => child.state === 'closed');
                const anyClosed = allChildren.some(child => child.state === 'closed');
                const anyOpen = allChildren.some(child => child.state === 'open');

                console.log(`${indent}üìä Parent #${parentNumber} status: ${allChildren.length} children, ${allChildren.filter(c => c.state === 'closed').length} closed, ${allChildren.filter(c => c.state === 'open').length} open`);

                const parentState = parentIssue.data.state;
                let actionTaken = false;

                // If all children closed and parent is open ‚Üí close parent
                if (allClosed && parentState === 'open') {
                  console.log(`${indent}‚úÖ All children closed, closing parent #${parentNumber}`);

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber,
                    state: 'closed',
                    state_reason: 'completed'
                  });


                  actionTaken = true;
                }

                // If any child open and parent is closed ‚Üí reopen parent
                if (anyOpen && parentState === 'closed') {
                  console.log(`${indent}üîì Child reopened, reopening parent #${parentNumber}`);

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber,
                    state: 'open'
                  });

                  const openChildren = allChildren.filter(c => c.state === 'open');

                  actionTaken = true;
                }

                if (!actionTaken) {
                  console.log(`${indent}‚è≠Ô∏è  Parent #${parentNumber} already in correct state (${parentState})`);
                }

                // Recursively sync grandparent
                await syncParentState(parentNumber, depth + 1);
              }

              // Start the sync chain from this issue
              await syncParentState(issueNumber);
              console.log('‚úÖ Parent state sync complete!');
            }
