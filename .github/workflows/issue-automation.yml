name: Issue Automation

on:
  issues:
    types: [opened, edited, reopened, milestoned, demilestoned, assigned, unassigned, labeled, unlabeled]

jobs:
  automate-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      repository-projects: write
      actions: write  # Needed to trigger rollup workflow

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @octokit/graphql

      - name: Auto-set Type and Inherit Milestone
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_WITH_PROJECT_ACCESS || secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = context.issue.number;
            const issueBody = context.payload.issue.body || '';
            const issueTitle = context.payload.issue.title || '';

            // Function to find all child issues (issues that reference this issue as parent)
            async function findChildIssues(parentNumber) {
              const allIssues = [];
              let page = 1;
              let hasMore = true;

              while (hasMore) {
                const issues = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  per_page: 100,
                  page: page
                });

                if (issues.data.length === 0) {
                  hasMore = false;
                } else {
                  allIssues.push(...issues.data);
                  page++;
                }
              }

              // Filter issues that reference this issue as parent
              const children = allIssues.filter(issue => {
                const body = issue.body || '';
                // Remove HTML comments to avoid matching examples
                const bodyWithoutComments = body.replace(/<!--[\s\S]*?-->/g, '');
                const parentPattern = new RegExp(`(?:Epic|Feature|Parent Feature|Parent Epic):\\s*#${parentNumber}(?:\\s|$)`, 'i');
                return parentPattern.test(bodyWithoutComments);
              });

              console.log(`Found ${children.length} child issue(s) of #${parentNumber}`);
              return children;
            }

            // Function to recursively update all descendants with milestone
            async function updateDescendantsMilestone(parentNumber, milestone, depth = 0, updatedIssues = new Set()) {
              const indent = '  '.repeat(depth);
              console.log(`${indent}Checking descendants of #${parentNumber}...`);

              const children = await findChildIssues(parentNumber);

              for (const child of children) {
                // Avoid infinite loops
                if (updatedIssues.has(child.number)) {
                  console.log(`${indent}‚è≠Ô∏è  Skipping #${child.number} (already processed)`);
                  continue;
                }

                updatedIssues.add(child.number);

                const currentMilestone = child.milestone ? child.milestone.number : null;
                const targetMilestone = milestone ? milestone.number : null;

                if (currentMilestone !== targetMilestone) {
                  console.log(`${indent}üìù Updating #${child.number} milestone from "${child.milestone?.title || 'none'}" to "${milestone?.title || 'none'}"`);

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: child.number,
                    milestone: targetMilestone
                  });

                  console.log(`${indent}‚úÖ Updated #${child.number}`);
                } else {
                  console.log(`${indent}‚è≠Ô∏è  #${child.number} already has correct milestone`);
                }

                // Recursively update grandchildren
                await updateDescendantsMilestone(child.number, milestone, depth + 1, updatedIssues);
              }

              return updatedIssues;
            }

            // Determine issue type from title prefix
            let issueType = null;
            if (issueTitle.startsWith('[EPIC]')) {
              issueType = 'Epic';
            } else if (issueTitle.startsWith('[FEATURE]')) {
              issueType = 'Feature';
            } else if (issueTitle.startsWith('[STORY]')) {
              issueType = 'User Story';
            } else if (issueTitle.startsWith('[Task]')) {
              issueType = 'Task';
            }

            console.log(`Issue #${issueNumber}: Type detected as "${issueType}"`);

            // Remove HTML comments from body to avoid matching examples
            const bodyWithoutComments = issueBody.replace(/<!--[\s\S]*?-->/g, '');

            // Extract parent issue reference
            const parentMatch = bodyWithoutComments.match(/(?:Epic|Feature|Parent Feature|Parent Epic):\s*#(\d+)/i);
            let parentIssueNumber = null;
            let parentMilestone = null;

            if (parentMatch) {
              parentIssueNumber = parseInt(parentMatch[1]);
              console.log(`Parent issue reference found: #${parentIssueNumber}`);

              // Get parent issue details to inherit milestone
              try {
                const parentIssue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parentIssueNumber
                });

                if (parentIssue.data.milestone) {
                  parentMilestone = parentIssue.data.milestone;
                  console.log(`Parent milestone found: ${parentMilestone.title}`);

                  // Set milestone on current issue
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    milestone: parentMilestone.number
                  });

                  console.log(`‚úÖ Milestone "${parentMilestone.title}" inherited from parent issue #${parentIssueNumber}`);
                } else {
                  console.log('Parent issue has no milestone set');
                }
              } catch (error) {
                console.error(`Error fetching parent issue #${parentIssueNumber}:`, error.message);
              }
            } else {
              console.log('No parent issue reference found in issue body');
            }

            // Set GitHub Issue Type field (organizational issue type)
            if (issueType) {
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  type: issueType
                });
                console.log(`‚úÖ Issue Type set to "${issueType}"`);
              } catch (error) {
                console.error('Error setting issue type:', error.message);
                console.log('‚ö†Ô∏è  Note: Issue types require push access and must be configured in your organization');
                console.log('‚ö†Ô∏è  Available types can be checked with: gh api orgs/:org/issue-types');
              }
            }

            // Set project field (Type) using GraphQL
            if (issueType) {
              try {
                // Get the issue node ID
                const issueData = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                const issueNodeId = issueData.data.node_id;

                // Find projects associated with this repository (organization-level)
                const projectsQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          fields(first: 20) {
                            nodes {
                              ... on ProjectV2SingleSelectField {
                                id
                                name
                                options {
                                  id
                                  name
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const projectsResult = await github.graphql(projectsQuery, {
                  owner: context.repo.owner
                });

                const projects = projectsResult.organization.projectsV2.nodes;
                console.log(`Found ${projects.length} project(s)`);

                // Find the specific project "[TEMPLATE] EngageMe"
                const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

                if (!project) {
                  console.log('‚ö†Ô∏è  [TEMPLATE] EngageMe project not found');
                } else {
                  console.log(`Processing project: ${project.title}`);

                  // Add issue to project first
                  const addToProjectMutation = `
                    mutation($projectId: ID!, $contentId: ID!) {
                      addProjectV2ItemById(input: {
                        projectId: $projectId
                        contentId: $contentId
                      }) {
                        item {
                          id
                        }
                      }
                    }
                  `;

                  let itemId;
                  try {
                    const addResult = await github.graphql(addToProjectMutation, {
                      projectId: project.id,
                      contentId: issueNodeId
                    });
                    itemId = addResult.addProjectV2ItemById.item.id;
                    console.log(`‚úÖ Issue added to project with item ID: ${itemId}`);
                  } catch (error) {
                    console.log(`Issue might already be in project: ${error.message}`);
                    // If already in project, we need to find the item ID
                    // Try to find it in the project items
                    const projectQuery = `
                      query($owner: String!) {
                        organization(login: $owner) {
                          projectsV2(first: 10) {
                            nodes {
                              id
                              title
                              items(first: 100) {
                                nodes {
                                  id
                                  content {
                                    ... on Issue {
                                      number
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const projectResult = await github.graphql(projectQuery, {
                      owner: context.repo.owner
                    });

                    const targetProject = projectResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
                    if (targetProject) {
                      const item = targetProject.items.nodes.find(i => i.content && i.content.number === issueNumber);
                      if (item) {
                        itemId = item.id;
                        console.log(`‚úÖ Found existing item ID: ${itemId}`);
                      }
                    }
                  }

                  if (!itemId) {
                    console.log('‚ö†Ô∏è  Could not get item ID, skipping project field update');
                  } else {
                    // Find the Type field
                    const typeField = project.fields.nodes.find(field =>
                      field.name === 'Type' && field.options
                    );

                    if (typeField) {
                      console.log(`Found Type field with ID: ${typeField.id}`);

                      // Find the matching option
                      const typeOption = typeField.options.find(opt =>
                        opt.name === issueType
                      );

                      if (typeOption) {
                        console.log(`Found matching type option: ${typeOption.name} (${typeOption.id})`);

                        // Update the field value
                        const updateFieldMutation = `
                          mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                            updateProjectV2ItemFieldValue(input: {
                              projectId: $projectId
                              itemId: $itemId
                              fieldId: $fieldId
                              value: {
                                singleSelectOptionId: $optionId
                              }
                            }) {
                              projectV2Item {
                                id
                              }
                            }
                          }
                        `;

                        await github.graphql(updateFieldMutation, {
                          projectId: project.id,
                          itemId: itemId,
                          fieldId: typeField.id,
                          optionId: typeOption.id
                        });

                        console.log(`‚úÖ Type field set to "${issueType}" in project "${project.title}"`);
                      } else {
                        console.log(`‚ö†Ô∏è Type option "${issueType}" not found in project field. Available options: ${typeField.options.map(o => o.name).join(', ')}`);
                      }
                    } else {
                      console.log('‚ö†Ô∏è Type field not found in project. Please create a single-select field named "Type" with options: Epic, Feature, User Story, Task');
                    }
                  }
                }
              } catch (error) {
                console.error('Error setting project field:', error.message);
                if (error.errors) {
                  console.error('GraphQL errors:', JSON.stringify(error.errors, null, 2));
                }
              }
            }

            // Cascade milestone updates to all descendants
            const currentMilestone = context.payload.issue.milestone;
            const actionType = context.payload.action;

            let updatedDescendants = new Set();
            if (['milestoned', 'demilestoned', 'edited'].includes(actionType)) {
              console.log(`\nüîÑ Cascading milestone changes to all descendants of #${issueNumber}...`);
              updatedDescendants = await updateDescendantsMilestone(issueNumber, currentMilestone);

              if (updatedDescendants.size > 0) {
                console.log(`‚úÖ Updated ${updatedDescendants.size} descendant issue(s) with milestone "${currentMilestone?.title || 'none'}"`);
              } else {
                console.log('‚ÑπÔ∏è  No descendants found or all already up-to-date');
              }
            }

            // Create comment summarizing automation actions
            let commentBody = '### ü§ñ Automation Summary\n\n';
            if (issueType) {
              commentBody += `‚úÖ **Type**: Set to \`${issueType}\`\n`;
            }
            if (parentMilestone) {
              commentBody += `‚úÖ **Milestone**: Inherited \`${parentMilestone.title}\` from parent issue #${parentIssueNumber}\n`;
            }
            if (parentIssueNumber && !parentMilestone) {
              commentBody += `‚ÑπÔ∏è **Note**: Parent issue #${parentIssueNumber} has no milestone to inherit\n`;
            }
            if (updatedDescendants.size > 0) {
              const descendantList = Array.from(updatedDescendants).map(n => `#${n}`).join(', ');
              commentBody += `\nüîÑ **Cascaded Updates**: Milestone propagated to ${updatedDescendants.size} descendant(s): ${descendantList}\n`;
            }

            if (issueType || parentMilestone || updatedDescendants.size > 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: commentBody
              });
            }

            // Automatically trigger rollup if this issue has a parent
            if (parentIssueNumber && context.payload.action === 'edited') {
              console.log(`\nüîÑ Triggering automatic rollup for parent #${parentIssueNumber}...`);
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'rollup-estimates.yml',
                  ref: 'main',
                  inputs: {
                    issue_number: issueNumber.toString()
                  }
                });
                console.log(`‚úÖ Rollup workflow triggered for issue #${issueNumber}`);
              } catch (error) {
                console.log(`‚ö†Ô∏è  Could not trigger rollup: ${error.message}`);
              }
            }
