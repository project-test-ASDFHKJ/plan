name: Scheduled Child Issues Sync

on:
  schedule:
    # Run every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      full_sync:
        description: 'Sync all issues (not just open)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  sync-children:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      repository-projects: write

    steps:
      - name: Sync Child Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_WITH_PROJECT_ACCESS || secrets.GITHUB_TOKEN }}
          script: |
            const fullSync = context.eventName === 'workflow_dispatch'
              ? context.payload.inputs.full_sync === 'true'
              : false;

            console.log(`Starting scheduled sync (full_sync: ${fullSync})...`);

            // Get all Epic and Feature issues
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: fullSync ? 'all' : 'open',
              per_page: 100
            });

            const parentIssues = issues.filter(issue =>
              !issue.pull_request &&
              (issue.title.startsWith('[EPIC]') || issue.title.startsWith('[FEATURE]'))
            );

            console.log(`Found ${parentIssues.length} parent issues to check`);

            let stats = {
              parentsChecked: 0,
              childrenFound: 0,
              childrenUpdated: 0,
              errors: 0
            };

            // Process each parent issue
            for (const parentIssue of parentIssues) {
              stats.parentsChecked++;
              console.log(`\n--- Checking #${parentIssue.number}: ${parentIssue.title} ---`);

              try {
                // Get children using GraphQL
                const graphqlQuery = `
                  query($owner: String!, $repo: String!, $issueNumber: Int!) {
                    repository(owner: $owner, name: $repo) {
                      issue(number: $issueNumber) {
                        trackedIssues(first: 100) {
                          nodes {
                            id
                            number
                            title
                            state
                            milestone {
                              number
                              title
                            }
                            labels(first: 20) {
                              nodes {
                                name
                              }
                            }
                            repository {
                              name
                              owner {
                                login
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const result = await github.graphql(graphqlQuery, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issueNumber: parentIssue.number
                });

                const children = result.repository.issue.trackedIssues.nodes;

                if (!children || children.length === 0) {
                  continue;
                }

                stats.childrenFound += children.length;
                console.log(`Found ${children.length} child(ren)`);

                // Get project
                const projectQuery = `
                  query($owner: String!) {
                    organization(login: $owner) {
                      projectsV2(first: 10) {
                        nodes {
                          id
                          title
                          items(first: 100) {
                            nodes {
                              content {
                                ... on Issue {
                                  id
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const projectsResult = await github.graphql(projectQuery, {
                  owner: context.repo.owner
                });

                const project = projectsResult.organization.projectsV2.nodes.find(
                  p => p.title === '[TEMPLATE] EngageMe'
                );

                // Process each child
                for (const child of children) {
                  const childOwner = child.repository?.owner?.login || context.repo.owner;
                  const childRepo = child.repository?.name || context.repo.repo;
                  const childNumber = child.number;
                  const isCrossRepo = childRepo !== context.repo.repo || childOwner !== context.repo.owner;
                  const repoLabel = isCrossRepo ? `${childOwner}/${childRepo}#${childNumber}` : `#${childNumber}`;

                  try {
                    let updated = false;

                    // Check if in project
                    if (project) {
                      const isInProject = project.items.nodes.some(item =>
                        item.content && item.content.id === child.id
                      );

                      if (!isInProject) {
                        console.log(`  âž• Adding ${repoLabel} to project`);
                        await github.graphql(`
                          mutation($projectId: ID!, $contentId: ID!) {
                            addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                              item { id }
                            }
                          }
                        `, {
                          projectId: project.id,
                          contentId: child.id
                        });
                        updated = true;
                      }
                    }

                    // Check milestone
                    const parentMilestone = parentIssue.milestone;
                    const childMilestone = child.milestone;

                    if (parentMilestone && (!childMilestone || childMilestone.number !== parentMilestone.number)) {
                      console.log(`  ðŸ“ Updating ${repoLabel} milestone to "${parentMilestone.title}"`);
                      await github.rest.issues.update({
                        owner: childOwner,
                        repo: childRepo,
                        issue_number: childNumber,
                        milestone: parentMilestone.number
                      });
                      updated = true;
                    }

                    if (updated) {
                      stats.childrenUpdated++;
                    }

                  } catch (error) {
                    if (error.status === 410) {
                      console.log(`  âš ï¸  ${repoLabel} was deleted`);
                    } else if (error.status === 404) {
                      console.log(`  âš ï¸  ${repoLabel} not found`);
                    } else {
                      console.log(`  âŒ Error updating ${repoLabel}: ${error.message}`);
                      stats.errors++;
                    }
                  }
                }

              } catch (error) {
                console.log(`âŒ Error processing parent #${parentIssue.number}: ${error.message}`);
                stats.errors++;
              }
            }

            // Summary
            console.log(`\n=== Sync Complete ===`);
            console.log(`Parents checked: ${stats.parentsChecked}`);
            console.log(`Children found: ${stats.childrenFound}`);
            console.log(`Children updated: ${stats.childrenUpdated}`);
            console.log(`Errors: ${stats.errors}`);

            // Create summary issue if there were updates
            if (stats.childrenUpdated > 0 || stats.errors > 0) {
              const summary = `# ðŸ”„ Scheduled Child Issues Sync

**Date:** ${new Date().toUTCString()}
**Mode:** ${fullSync ? 'Full' : 'Incremental'}

## Summary

- **Parents checked:** ${stats.parentsChecked}
- **Children found:** ${stats.childrenFound}
- **Children updated:** ${stats.childrenUpdated}
- **Errors:** ${stats.errors}

${stats.errors > 0 ? 'âš ï¸ Some issues encountered errors. Check workflow logs for details.' : 'âœ… All children synchronized successfully'}
`;

              // Find or create sync log issue
              const syncIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'automation-sync-log',
                state: 'open',
                per_page: 1
              });

              if (syncIssues.data.length > 0) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: syncIssues.data[0].number,
                  body: summary
                });
              } else {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: 'ðŸ”„ Automation Sync Log',
                  body: 'This issue tracks scheduled synchronization of child issues.\n\n' + summary,
                  labels: ['automation-sync-log', 'automation']
                });
              }
            }
