name: Scheduled Rollup - All Issues

on:
  schedule:
    # Run every 15 minutes
    - cron: '*/15 * * * *'
  workflow_dispatch:  # Allow manual triggering

jobs:
  rollup-all-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      repository-projects: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Rollup All Parent Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_WITH_PROJECT_ACCESS || secrets.GITHUB_TOKEN }}
          script: |
            console.log('üîÑ Scheduled rollup started');
            console.log('=====================================');

            // Function to get all project fields for an issue
            // Supports cross-repo by accepting owner/repo parameters
            async function getProjectFields(issueNumber, owner = context.repo.owner, repo = context.repo.repo) {
              const issue = await github.rest.issues.get({
                owner: owner,
                repo: repo,
                issue_number: issueNumber
              });

              // Get all projects and their items (organization-level projects)
              const projectQuery = `
                query($owner: String!) {
                  organization(login: $owner) {
                    projectsV2(first: 10) {
                      nodes {
                        id
                        title
                        items(first: 100) {
                          nodes {
                            id
                            content {
                              ... on Issue {
                                id
                                number
                                repository {
                                  name
                                  owner {
                                    login
                                  }
                                }
                              }
                            }
                            fieldValues(first: 20) {
                              nodes {
                                ... on ProjectV2ItemFieldNumberValue {
                                  number
                                  field {
                                    ... on ProjectV2Field {
                                      id
                                      name
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        fields(first: 20) {
                          nodes {
                            ... on ProjectV2Field {
                              id
                              name
                              dataType
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `;

              const projectResult = await github.graphql(projectQuery, {
                owner: context.repo.owner
              });

              const projects = projectResult.organization.projectsV2.nodes;

              // Find the specific project "[TEMPLATE] EngageMe"
              const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

              if (!project) {
                return null;
              }

              // Find the item for this issue (match by number AND repository for cross-repo support)
              const item = project.items.nodes.find(i => {
                if (!i.content || i.content.number !== issueNumber) return false;

                // For cross-repo, also match repository
                const itemOwner = i.content.repository?.owner?.login || context.repo.owner;
                const itemRepo = i.content.repository?.name || context.repo.repo;

                return itemOwner === owner && itemRepo === repo;
              });

              if (item) {
                const fields = {};
                item.fieldValues.nodes.forEach(fv => {
                  if (fv.field && fv.number !== undefined) {
                    fields[fv.field.name] = {
                      value: fv.number,
                      fieldId: fv.field.id
                    };
                  }
                });

                return {
                  projectId: project.id,
                  itemId: item.id,
                  fields: fields,
                  allFields: project.fields.nodes
                };
              }

              return null;
            }

            // Function to update project field
            async function updateProjectField(projectId, itemId, fieldId, value) {
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: Float!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: {
                      number: $value
                    }
                  }) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;

              await github.graphql(mutation, {
                projectId: projectId,
                itemId: itemId,
                fieldId: fieldId,
                value: value
              });
            }

            // Get all issues from ALL repos via the project
            console.log('Fetching all issues from project (all repos)...');

            const allProjectItemsQuery = `
              query($owner: String!) {
                organization(login: $owner) {
                  projectsV2(first: 10) {
                    nodes {
                      title
                      items(first: 100) {
                        nodes {
                          content {
                            ... on Issue {
                              id
                              number
                              title
                              state
                              repository {
                                name
                                owner {
                                  login
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            const projectItemsResult = await github.graphql(allProjectItemsQuery, {
              owner: context.repo.owner
            });

            const targetProject = projectItemsResult.organization.projectsV2.nodes.find(p => p.title === '[TEMPLATE] EngageMe');
            if (!targetProject) {
              console.log('‚ùå Project not found');
              return;
            }

            const allIssues = targetProject.items.nodes
              .filter(item => item.content && item.content.number && item.content.state === 'OPEN')
              .map(item => ({
                number: item.content.number,
                title: item.content.title,
                state: item.content.state,
                owner: item.content.repository?.owner?.login || context.repo.owner,
                repo: item.content.repository?.name || context.repo.repo
              }));

            const totalIssuesInProject = targetProject.items.nodes.filter(item => item.content && item.content.number).length;
            console.log(`Found ${totalIssuesInProject} total issues in project (${allIssues.length} open, ignoring closed)`);

            // Group issues by repository
            const repoGroups = new Map();
            for (const issue of allIssues) {
              const repoKey = `${issue.owner}/${issue.repo}`;
              if (!repoGroups.has(repoKey)) {
                repoGroups.set(repoKey, []);
              }
              repoGroups.get(repoKey).push(issue);
            }

            console.log(`Issues span ${repoGroups.size} repositories:`);
            for (const [repoKey, issues] of repoGroups) {
              console.log(`  ${repoKey}: ${issues.length} issues`);
            }

            // Build parent-child relationships using GitHub's native sub-issues (cross-repo)
            const parentChildMap = new Map();
            const childParentMap = new Map();

            console.log('\nBuilding parent-child relationships using REST API...');

            let apiCallCount = 0;
            let successCount = 0;

            for (const issue of allIssues) {
              try {
                // Use REST API sub_issues endpoint (supports cross-repo)
                const response = await github.request('GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues', {
                  owner: issue.owner,
                  repo: issue.repo,
                  issue_number: issue.number
                });

                apiCallCount++;

                if (response.data && response.data.length > 0) {
                  const children = response.data.map(child => ({
                    number: child.number,
                    owner: child.repository?.owner?.login || issue.owner,
                    repo: child.repository?.name || issue.repo
                  }));

                  successCount++;

                  // Log with repo info for cross-repo children
                  const childLabels = children.map(c => {
                    if (c.repo !== issue.repo) {
                      return `${c.repo}#${c.number}`;
                    }
                    return `#${c.number}`;
                  }).join(', ');

                  const issueKey = `${issue.owner}/${issue.repo}#${issue.number}`;
                  console.log(`‚úÖ ${issueKey} has ${children.length} children: ${childLabels}`);

                  parentChildMap.set(issueKey, children);

                  for (const child of children) {
                    const childKey = `${child.owner}/${child.repo}#${child.number}`;
                    childParentMap.set(childKey, issueKey);
                  }
                }
              } catch (error) {
                // 404 means no sub-issues endpoint access or no children - that's okay
                if (error.status !== 404) {
                  console.log(`‚ö†Ô∏è  Error checking ${issue.owner}/${issue.repo}#${issue.number}: ${error.message}`);
                }
              }
            }

            console.log(`API Statistics: ${apiCallCount} issues checked, ${successCount} with children`);
            console.log(`Found ${parentChildMap.size} parent issues with children`);

            // Process each parent issue
            let updatedCount = 0;

            for (const [parentKey, children] of parentChildMap.entries()) {
              console.log(`\nüìä Processing parent ${parentKey} with ${children.length} children`);

              // Extract parent info from key (format: owner/repo#number)
              const [parentOwnerRepo, parentNumberStr] = parentKey.split('#');
              const [parentOwner, parentRepo] = parentOwnerRepo.split('/');
              const parentNumber = parseInt(parentNumberStr);

              // Calculate totals from children
              let totalEstimate = 0;
              let totalRemaining = 0;
              const childDetails = [];

              for (const child of children) {
                const childOwner = child.owner;
                const childRepo = child.repo;
                const childNumber = child.number;

                // Check if child is closed - skip if so
                try {
                  const childIssue = await github.rest.issues.get({
                    owner: childOwner,
                    repo: childRepo,
                    issue_number: childNumber
                  });

                  if (childIssue.data.state === 'closed') {
                    const repoLabel = childRepo !== context.repo.repo ? `${childRepo}#${childNumber}` : `#${childNumber}`;
                    console.log(`  ${repoLabel}: SKIPPED (closed)`);
                    continue;
                  }
                } catch (error) {
                  console.log(`  ‚ö†Ô∏è  Could not check state for child #${childNumber}: ${error.message}`);
                  continue;
                }

                const projectFields = await getProjectFields(childNumber, childOwner, childRepo);

                if (projectFields && projectFields.fields) {
                  const estimate = projectFields.fields['Estimate']?.value || 0;
                  const remaining = projectFields.fields['Remaining']?.value || 0;

                  totalEstimate += estimate;
                  totalRemaining += remaining;

                  const repoLabel = childRepo !== context.repo.repo ? `${childRepo}#${childNumber}` : `#${childNumber}`;
                  childDetails.push({
                    number: childNumber,
                    repo: childRepo,
                    estimate: estimate,
                    remaining: remaining
                  });

                  if (estimate > 0 || remaining > 0) {
                    console.log(`  ${repoLabel}: Estimate=${estimate}, Remaining=${remaining}`);
                  }
                }
              }

              console.log(`Total: Estimate=${totalEstimate}, Remaining=${totalRemaining}`);

              // Get parent's project fields
              const parentProjectFields = await getProjectFields(parentNumber, parentOwner, parentRepo);

              if (!parentProjectFields) {
                console.log(`‚ö†Ô∏è  Parent #${parentNumber} not found in project`);
                continue;
              }

              // Find Estimate and Remaining field IDs
              const estimateField = parentProjectFields.allFields.find(f => f.name === 'Estimate');
              const remainingField = parentProjectFields.allFields.find(f => f.name === 'Remaining');

              if (!estimateField || !remainingField) {
                console.log(`‚ö†Ô∏è  Estimate or Remaining fields not found`);
                continue;
              }

              // Check if values need updating
              const currentEstimate = parentProjectFields.fields['Estimate']?.value || 0;
              const currentRemaining = parentProjectFields.fields['Remaining']?.value || 0;

              if (currentEstimate !== totalEstimate || currentRemaining !== totalRemaining) {
                // Update parent's fields
                try {
                  await updateProjectField(
                    parentProjectFields.projectId,
                    parentProjectFields.itemId,
                    estimateField.id,
                    totalEstimate
                  );

                  await updateProjectField(
                    parentProjectFields.projectId,
                    parentProjectFields.itemId,
                    remainingField.id,
                    totalRemaining
                  );

                  console.log(`‚úÖ Updated #${parentNumber}: Estimate=${totalEstimate}, Remaining=${totalRemaining}`);
                  updatedCount++;
                } catch (error) {
                  console.error(`Error updating parent #${parentNumber}:`, error.message);
                }
              } else {
                console.log(`‚è≠Ô∏è  #${parentNumber} already up-to-date`);
              }
            }

            console.log('\n=====================================');
            console.log(`‚úÖ Scheduled rollup complete!`);
            console.log(`Updated ${updatedCount} parent issue(s)`);
