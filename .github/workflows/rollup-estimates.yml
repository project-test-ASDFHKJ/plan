name: Rollup Estimates and Remaining Work

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Task/Story number that was updated (triggers bottom-up rollup to parents)'
        required: true
        type: number
  issues:
    types: [edited, labeled]

jobs:
  rollup-to-parents:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      repository-projects: write
      # Note: GITHUB_TOKEN cannot access organization-level projects
      # Organization projects require elevated permissions

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Rollup Estimates to Parent Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('ğŸ”„ Rollup workflow triggered');
            console.log('=====================================');

            // Determine issue number based on trigger type
            let issueNumber;
            if (context.eventName === 'workflow_dispatch') {
              // Manual trigger
              issueNumber = parseInt(context.payload.inputs.issue_number);
              console.log(`ğŸ“‹ Manual trigger for issue #${issueNumber}`);
            } else if (context.eventName === 'issues') {
              // Issue event trigger
              issueNumber = context.issue.number;
              console.log(`ğŸ“‹ Issue event trigger for issue #${issueNumber}`);
            } else {
              console.log('âŒ Unknown trigger type');
              return;
            }

            // Get issue details
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });

            const issueBody = issue.data.body || '';
            console.log(`ğŸ“Œ Processing: #${issueNumber} - ${issue.data.title}`);
            console.log(`ğŸ“Š Workflow: CHILD â†’ PARENT rollup (bottom-up)`);
            console.log('=====================================\n');

            // Remove HTML comments from body to avoid matching examples
            const bodyWithoutComments = issueBody.replace(/<!--[\s\S]*?-->/g, '');

            // Extract parent issue reference
            const parentMatch = bodyWithoutComments.match(/(?:Epic|Feature|Parent Feature|Parent Epic):\s*#(\d+)/i);

            if (!parentMatch) {
              console.log('â„¹ï¸  No parent issue reference found');
              console.log('This issue is either:');
              console.log('  - A top-level Epic (no parent needed)');
              console.log('  - Missing a parent reference in the body');
              return;
            }

            const parentIssueNumber = parseInt(parentMatch[1]);
            console.log(`âœ… Parent issue found: #${parentIssueNumber}`);

            // Function to get all project fields for an issue
            async function getProjectFields(issueNumber) {
              const issue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });

              // Get all projects and their items (organization-level projects)
              const projectQuery = `
                query($owner: String!) {
                  organization(login: $owner) {
                    projectsV2(first: 10) {
                      nodes {
                        id
                        title
                        items(first: 100) {
                          nodes {
                            id
                            content {
                              ... on Issue {
                                id
                                number
                              }
                            }
                            fieldValues(first: 20) {
                              nodes {
                                ... on ProjectV2ItemFieldNumberValue {
                                  number
                                  field {
                                    ... on ProjectV2Field {
                                      id
                                      name
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        fields(first: 20) {
                          nodes {
                            ... on ProjectV2Field {
                              id
                              name
                              dataType
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `;

              const projectResult = await github.graphql(projectQuery, {
                owner: context.repo.owner
              });

              const projects = projectResult.organization.projectsV2.nodes;

              // Find the specific project "[TEMPLATE] EngageMe"
              const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

              if (!project) {
                console.log(`âš ï¸  Issue #${issueNumber} - [TEMPLATE] EngageMe project not found`);
                return null;
              }

              // Find the item for this issue
              const item = project.items.nodes.find(i =>
                i.content && i.content.number === issueNumber
              );

              if (item) {
                const fields = {};
                item.fieldValues.nodes.forEach(fv => {
                  if (fv.field && fv.number !== undefined) {
                    fields[fv.field.name] = {
                      value: fv.number,
                      fieldId: fv.field.id
                    };
                  }
                });

                return {
                  projectId: project.id,
                  itemId: item.id,
                  fields: fields,
                  allFields: project.fields.nodes
                };
              }

              return null;
            }

            // Function to update project field
            async function updateProjectField(projectId, itemId, fieldId, value) {
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: Float!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: {
                      number: $value
                    }
                  }) {
                    projectV2Item {
                      id
                    }
                  }
                }
              `;

              await github.graphql(mutation, {
                projectId: projectId,
                itemId: itemId,
                fieldId: fieldId,
                value: value
              });
            }

            // Function to find all children and sum their estimates and remaining work
            async function calculateChildrenSums(parentNumber) {
              const allIssues = [];
              let page = 1;
              let hasMore = true;

              console.log(`Finding all children of #${parentNumber}...`);

              while (hasMore) {
                const issues = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  per_page: 100,
                  page: page
                });

                if (issues.data.length === 0) {
                  hasMore = false;
                } else {
                  allIssues.push(...issues.data);
                  page++;
                }
              }

              // Filter children
              const children = allIssues.filter(issue => {
                const body = issue.body || '';
                const parentPattern = new RegExp(`(?:Epic|Feature|Parent Feature|Parent Epic):\\s*#${parentNumber}(?:\\s|$)`, 'i');
                return parentPattern.test(body);
              });

              console.log(`Found ${children.length} child issue(s)`);

              let totalEstimate = 0;
              let totalRemaining = 0;
              const childDetails = [];

              for (const child of children) {
                const projectFields = await getProjectFields(child.number);

                if (projectFields && projectFields.fields) {
                  const estimate = projectFields.fields['Estimate']?.value || 0;
                  const remaining = projectFields.fields['Remaining']?.value || 0;

                  totalEstimate += estimate;
                  totalRemaining += remaining;

                  childDetails.push({
                    number: child.number,
                    estimate: estimate,
                    remaining: remaining
                  });

                  console.log(`  #${child.number}: Estimate=${estimate}, Remaining=${remaining}`);
                }
              }

              return {
                totalEstimate,
                totalRemaining,
                childCount: children.length,
                childDetails
              };
            }

            // Function to recursively update parent chain
            async function updateParentChain(parentNumber, depth = 0) {
              const indent = '  '.repeat(depth);
              console.log(`${indent}ğŸ“Š Updating parent #${parentNumber}...`);

              // Check if parent issue exists
              try {
                await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parentNumber
                });
              } catch (error) {
                console.error(`${indent}âŒ Parent issue #${parentNumber} not found (404)`);
                return;
              }

              // Calculate sums from all children
              const sums = await calculateChildrenSums(parentNumber);

              console.log(`${indent}Total from ${sums.childCount} children: Estimate=${sums.totalEstimate}, Remaining=${sums.totalRemaining}`);

              // Get parent's project fields
              const parentProjectFields = await getProjectFields(parentNumber);

              if (!parentProjectFields) {
                console.log(`${indent}âš ï¸  Parent #${parentNumber} not found in any project`);
                return;
              }

              // Find Estimate and Remaining field IDs
              const estimateField = parentProjectFields.allFields.find(f => f.name === 'Estimate');
              const remainingField = parentProjectFields.allFields.find(f => f.name === 'Remaining');

              if (!estimateField || !remainingField) {
                console.log(`${indent}âš ï¸  Estimate or Remaining fields not found in project`);
                return;
              }

              // Update parent's fields
              try {
                await updateProjectField(
                  parentProjectFields.projectId,
                  parentProjectFields.itemId,
                  estimateField.id,
                  sums.totalEstimate
                );
                console.log(`${indent}âœ… Updated Estimate to ${sums.totalEstimate}`);

                await updateProjectField(
                  parentProjectFields.projectId,
                  parentProjectFields.itemId,
                  remainingField.id,
                  sums.totalRemaining
                );
                console.log(`${indent}âœ… Updated Remaining to ${sums.totalRemaining}`);

                // Post comment on parent
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parentNumber,
                  body: `### ğŸ“Š Rollup Update\n\n**Estimate**: ${sums.totalEstimate} (sum of ${sums.childCount} children)\n**Remaining**: ${sums.totalRemaining}\n\n**Children:**\n${sums.childDetails.map(c => `- #${c.number}: Estimate=${c.estimate}, Remaining=${c.remaining}`).join('\n')}\n\n*Automatically calculated from child issues*`
                });

              } catch (error) {
                console.error(`${indent}Error updating parent:`, error.message);
                return;
              }

              // Find grandparent and continue chain
              const parentIssue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parentNumber
              });

              const parentBody = parentIssue.data.body || '';
              const grandparentMatch = parentBody.match(/(?:Epic|Feature|Parent Feature|Parent Epic):\s*#(\d+)/i);

              if (grandparentMatch) {
                const grandparentNumber = parseInt(grandparentMatch[1]);
                console.log(`${indent}Found grandparent #${grandparentNumber}, continuing chain...`);
                await updateParentChain(grandparentNumber, depth + 1);
              } else {
                console.log(`${indent}No grandparent found, rollup complete`);
              }
            }

            // Start the rollup chain
            await updateParentChain(parentIssueNumber);

            console.log('âœ… Rollup complete!');
