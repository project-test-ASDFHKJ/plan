name: Generate Burndown Report

on:
  schedule:
    # Run daily at midnight UTC
    - cron: '0 0 * * *'
  workflow_dispatch:  # Allow manual triggering

jobs:
  generate-burndown:
    runs-on: ubuntu-latest
    permissions:
      issues: read
      contents: write
      repository-projects: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install chart dependencies
        run: npm install chartjs-node-canvas date-fns

      - name: Generate Burndown Report
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_WITH_PROJECT_ACCESS || secrets.GITHUB_TOKEN }}
          script: |
            console.log('ðŸ“Š Burndown report generation started');
            console.log('=====================================');

            const fs = require('fs');
            const path = require('path');
            const { ChartJSNodeCanvas } = require('chartjs-node-canvas');
            const { format, parseISO, differenceInDays, addDays } = require('date-fns');

            // Function to get all issues and their project fields
            async function getProjectData() {
              const projectQuery = `
                query($owner: String!) {
                  organization(login: $owner) {
                    projectsV2(first: 10) {
                      nodes {
                        id
                        title
                        items(first: 100) {
                          nodes {
                            id
                            content {
                              ... on Issue {
                                id
                                number
                                title
                                state
                                createdAt
                                closedAt
                              }
                            }
                            fieldValues(first: 20) {
                              nodes {
                                ... on ProjectV2ItemFieldNumberValue {
                                  number
                                  field {
                                    ... on ProjectV2Field {
                                      id
                                      name
                                    }
                                  }
                                }
                                ... on ProjectV2ItemFieldIterationValue {
                                  title
                                  startDate
                                  duration
                                  iterationId
                                  field {
                                    ... on ProjectV2IterationField {
                                      id
                                      name
                                    }
                                  }
                                }
                                ... on ProjectV2ItemFieldSingleSelectValue {
                                  name
                                  field {
                                    ... on ProjectV2SingleSelectField {
                                      id
                                      name
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        fields(first: 20) {
                          nodes {
                            ... on ProjectV2IterationField {
                              id
                              name
                              configuration {
                                iterations {
                                  id
                                  title
                                  startDate
                                  duration
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `;

              const projectResult = await github.graphql(projectQuery, {
                owner: context.repo.owner
              });

              const projects = projectResult.organization.projectsV2.nodes;
              const project = projects.find(p => p.title === '[TEMPLATE] EngageMe');

              if (!project) {
                throw new Error('[TEMPLATE] EngageMe project not found');
              }

              return project;
            }

            // Get project data
            const project = await getProjectData();
            console.log(`Found project: ${project.title}`);

            // Get all iterations
            const iterationField = project.fields.nodes.find(f => f.name === 'Iteration');
            if (!iterationField || !iterationField.configuration || !iterationField.configuration.iterations) {
              console.log('âš ï¸  No iteration field found in project');
              return;
            }

            const iterations = iterationField.configuration.iterations;
            console.log(`Found ${iterations.length} iteration(s)`);

            // Process each iteration
            const iterationStats = [];

            for (const iteration of iterations) {
              console.log(`\nðŸ“… Processing iteration: ${iteration.title}`);

              // Find all issues in this iteration
              const issuesInIteration = project.items.nodes.filter(item => {
                if (!item.content) return false;

                const iterationValue = item.fieldValues.nodes.find(fv =>
                  fv.field && fv.field.name === 'Iteration' && fv.iterationId === iteration.id
                );

                return iterationValue !== undefined;
              });

              console.log(`  Found ${issuesInIteration.length} issue(s) in iteration`);

              // Calculate stats
              let totalEstimate = 0;
              let totalRemaining = 0;
              let completedCount = 0;
              let totalCount = issuesInIteration.length;

              const issueDetails = [];

              for (const item of issuesInIteration) {
                const issue = item.content;

                // Extract Estimate and Remaining
                let estimate = 0;
                let remaining = 0;
                let type = 'Unknown';

                item.fieldValues.nodes.forEach(fv => {
                  if (fv.field) {
                    if (fv.field.name === 'Estimate' && fv.number !== undefined) {
                      estimate = fv.number;
                    }
                    if (fv.field.name === 'Remaining' && fv.number !== undefined) {
                      remaining = fv.number;
                    }
                    if (fv.field.name === 'Type' && fv.name) {
                      type = fv.name;
                    }
                  }
                });

                totalEstimate += estimate;
                totalRemaining += remaining;

                if (issue.state === 'closed') {
                  completedCount++;
                }

                issueDetails.push({
                  number: issue.number,
                  title: issue.title,
                  state: issue.state,
                  type: type,
                  estimate: estimate,
                  remaining: remaining,
                  completed: estimate - remaining
                });
              }

              const totalCompleted = totalEstimate - totalRemaining;
              const completionPercent = totalEstimate > 0 ? Math.round((totalCompleted / totalEstimate) * 100) : 0;

              // Calculate iteration dates
              const startDate = new Date(iteration.startDate);
              const endDate = new Date(startDate);
              endDate.setDate(endDate.getDate() + iteration.duration);

              const today = new Date();
              const daysElapsed = Math.max(0, Math.ceil((today - startDate) / (1000 * 60 * 60 * 24)));
              const daysRemaining = Math.max(0, Math.ceil((endDate - today) / (1000 * 60 * 60 * 24)));
              const totalDays = iteration.duration;

              // Calculate velocity (work per day)
              const velocity = daysElapsed > 0 ? (totalCompleted / daysElapsed).toFixed(1) : 0;
              const projectedCompletion = velocity > 0 ? Math.ceil(totalRemaining / velocity) : 0;

              iterationStats.push({
                title: iteration.title,
                startDate: startDate.toISOString().split('T')[0],
                endDate: endDate.toISOString().split('T')[0],
                daysElapsed: daysElapsed,
                daysRemaining: daysRemaining,
                totalDays: totalDays,
                totalEstimate: totalEstimate,
                totalRemaining: totalRemaining,
                totalCompleted: totalCompleted,
                completionPercent: completionPercent,
                velocity: velocity,
                projectedCompletion: projectedCompletion,
                completedCount: completedCount,
                totalCount: totalCount,
                issueDetails: issueDetails
              });

              console.log(`  Total Estimate: ${totalEstimate}, Remaining: ${totalRemaining}, Completed: ${totalCompleted} (${completionPercent}%)`);
              console.log(`  Velocity: ${velocity} per day, Projected completion in ${projectedCompletion} days`);
            }

            // Generate burndown chart (single file for current active iteration)
            const width = 1200;
            const height = 600;
            const chartJSNodeCanvas = new ChartJSNodeCanvas({ width, height });

            // Find the most recent/active iteration (highest remaining work)
            let activeIteration = null;
            let maxRemaining = 0;

            for (const stats of iterationStats) {
              if (stats.totalRemaining > maxRemaining) {
                maxRemaining = stats.totalRemaining;
                activeIteration = stats;
              }
            }

            // If no active iteration, use the first one
            if (!activeIteration && iterationStats.length > 0) {
              activeIteration = iterationStats[0];
            }

            if (activeIteration) {
              console.log(`\nðŸ“ˆ Generating chart for active iteration: ${activeIteration.title}...`);

              // Prepare data points for current snapshot
              const startDate = parseISO(activeIteration.startDate);
              const endDate = parseISO(activeIteration.endDate);
              const today = new Date();
              const totalDays = differenceInDays(endDate, startDate);
              const elapsedDays = Math.min(totalDays, differenceInDays(today, startDate));

              // Generate all dates in range
              const allDates = [];
              for (let i = 0; i <= totalDays; i++) {
                const date = addDays(startDate, i);
                allDates.push(format(date, 'yyyy-MM-dd'));
              }

              // Current snapshot data
              const remainingData = [];
              const idealTrendData = [];

              const initialEstimate = activeIteration.totalEstimate;
              const currentRemaining = activeIteration.totalRemaining;

              allDates.forEach((date, index) => {
                // Ideal trend: linear burndown from start to zero
                const idealRemaining = initialEstimate * (1 - index / totalDays);
                idealTrendData.push(Math.max(0, idealRemaining));

                // Actual remaining: show current value at today's position
                if (index < elapsedDays) {
                  // Past: interpolate from initial to current
                  const progress = index / elapsedDays;
                  const burned = (initialEstimate - currentRemaining) * progress;
                  remainingData.push(initialEstimate - burned);
                } else if (index === elapsedDays) {
                  // Today: current value
                  remainingData.push(currentRemaining);
                } else {
                  // Future: null (no data)
                  remainingData.push(null);
                }
              });

              // Format dates for display (MM/DD)
              const labels = allDates.map(date => format(parseISO(date), 'MM/dd'));

              // Chart configuration (Azure DevOps style)
              const configuration = {
                type: 'line',
                data: {
                  labels: labels,
                  datasets: [
                    {
                      label: 'Remaining',
                      data: remainingData,
                      fill: true,
                      backgroundColor: 'rgba(0, 120, 212, 0.3)', // Azure blue
                      borderColor: 'rgba(0, 120, 212, 1)',
                      borderWidth: 2,
                      tension: 0.1,
                      pointRadius: 3,
                      pointBackgroundColor: 'rgba(0, 120, 212, 1)',
                      spanGaps: false
                    },
                    {
                      label: 'Ideal Trend',
                      data: idealTrendData,
                      fill: false,
                      borderColor: 'rgba(150, 150, 150, 0.8)',
                      borderWidth: 2,
                      borderDash: [],
                      tension: 0,
                      pointRadius: 0
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    title: {
                      display: true,
                      text: `Burndown - ${activeIteration.title}`,
                      font: { size: 20, weight: 'bold' },
                      color: '#ffffff'
                    },
                    legend: {
                      display: true,
                      position: 'bottom',
                      labels: {
                        color: '#ffffff',
                        font: { size: 12 }
                      }
                    }
                  },
                  scales: {
                    x: {
                      grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                      },
                      ticks: {
                        color: '#ffffff',
                        font: { size: 11 }
                      }
                    },
                    y: {
                      beginAtZero: true,
                      grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                      },
                      ticks: {
                        color: '#ffffff',
                        font: { size: 11 }
                      },
                      title: {
                        display: true,
                        text: 'Work Remaining',
                        color: '#ffffff',
                        font: { size: 14 }
                      }
                    }
                  },
                  layout: {
                    padding: 20
                  }
                },
                plugins: [{
                  id: 'customCanvasBackgroundColor',
                  beforeDraw: (chart) => {
                    const ctx = chart.canvas.getContext('2d');
                    ctx.save();
                    ctx.globalCompositeOperation = 'destination-over';
                    ctx.fillStyle = '#2d2d2d'; // Dark background like Azure DevOps
                    ctx.fillRect(0, 0, chart.width, chart.height);
                    ctx.restore();
                  }
                }]
              };

              // Generate chart image (single file)
              const imageBuffer = await chartJSNodeCanvas.renderToBuffer(configuration);
              const chartPath = 'burndown-chart.png';

              fs.writeFileSync(chartPath, imageBuffer);
              console.log(`âœ… Chart saved to ${chartPath}`);

              // Mark that we have a chart
              activeIteration.hasChart = true;
            } else {
              console.log('No active iteration found, skipping chart generation');
            }

            // Generate markdown report
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0];
            const timeStr = now.toISOString().split('T')[1].split('.')[0];

            let markdown = `# Burndown Report\n\n`;
            markdown += `**Generated:** ${dateStr} at ${timeStr} UTC\n\n`;
            markdown += `**Project:** [TEMPLATE] EngageMe\n\n`;
            markdown += `---\n\n`;

            if (iterationStats.length === 0) {
              markdown += `*No iterations found or no issues assigned to iterations.*\n`;
            } else {
              for (const stats of iterationStats) {
                markdown += `## ${stats.title}\n\n`;

                // Summary metrics (similar to Azure DevOps top section)
                markdown += `<table>\n`;
                markdown += `<tr>\n`;
                markdown += `<td><strong>Remaining Work</strong><br/>${stats.totalRemaining}h</td>\n`;
                markdown += `<td><strong>Completed</strong><br/>${stats.completionPercent}%</td>\n`;
                markdown += `<td><strong>Average Burndown</strong><br/>${stats.velocity}h/day</td>\n`;
                markdown += `<td><strong>Total Scope</strong><br/>${stats.totalEstimate}h</td>\n`;
                markdown += `</tr>\n`;
                markdown += `</table>\n\n`;

                markdown += `**Duration:** ${stats.startDate} to ${stats.endDate} (${stats.totalDays} days)  \n`;
                markdown += `**Progress:** Day ${stats.daysElapsed} of ${stats.totalDays} (${stats.daysRemaining} days remaining)\n\n`;

                // Burndown chart image (only for active iteration)
                if (activeIteration && stats.title === activeIteration.title && activeIteration.hasChart) {
                  markdown += `### Burndown Chart\n\n`;
                  markdown += `![Burndown Chart](burndown-chart.png)\n\n`;
                }

                // Additional metrics
                markdown += `### Metrics\n\n`;
                markdown += `| Metric | Value |\n`;
                markdown += `|--------|-------|\n`;
                markdown += `| **Issues Closed** | ${stats.completedCount} / ${stats.totalCount} |\n`;

                if (stats.projectedCompletion > 0) {
                  const onTrack = stats.projectedCompletion <= stats.daysRemaining;
                  const status = onTrack ? 'âœ… On Track' : 'âš ï¸ At Risk';
                  markdown += `| **Projected Completion** | ${stats.projectedCompletion} days (${status}) |\n`;
                }

                markdown += `\n`;

                // Issue breakdown
                markdown += `<details>\n`;
                markdown += `<summary><strong>View All Issues (${stats.issueDetails.length})</strong></summary>\n\n`;
                markdown += `| # | Title | Type | State | Estimate | Remaining | Completed |\n`;
                markdown += `|---|-------|------|-------|----------|-----------|----------|\n`;

                for (const issue of stats.issueDetails) {
                  const stateIcon = issue.state === 'closed' ? 'âœ…' : 'ðŸ”µ';
                  markdown += `| ${stateIcon} #${issue.number} | ${issue.title} | ${issue.type} | ${issue.state} | ${issue.estimate}h | ${issue.remaining}h | ${issue.completed}h |\n`;
                }

                markdown += `\n</details>\n\n`;
                markdown += `---\n\n`;
              }
            }

            markdown += `\n*This report is automatically generated daily by GitHub Actions.*\n`;

            // Write to file
            fs.writeFileSync('BURNDOWN.md', markdown);
            console.log('\nâœ… Burndown report written to BURNDOWN.md');

            // Show preview
            console.log('\nðŸ“„ Report preview (first 500 chars):');
            console.log(markdown.substring(0, 500) + '...');

      - name: Commit and push changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add BURNDOWN.md
          git add burndown-chart.png
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update burndown report and chart - $(date -u +%Y-%m-%d)"
            git push
            echo "âœ… Burndown report and chart committed and pushed"
          fi
